{"ast":null,"code":"function Diff() {}\n\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\n\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n} //\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\n\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n} // Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\n\n\nfunction distanceIterator(start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange; // If we have previous context, start with that\n\n\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2; // Overlapping\n\n\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3; // end the range and output\n\n\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\n\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\n\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\n\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\n\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines; // Mine inserted\n\n\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2; // Theirs inserted\n\n\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n} // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\n\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };","map":{"version":3,"sources":["C:/reactjs/Udemy/NetCore/react-peliculas/node_modules/diff/lib/index.mjs"],"names":["Diff","prototype","diff","oldString","newString","options","arguments","length","undefined","callback","self","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path","characterDiff","diffChars","oldStr","newStr","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","splice","diffWords","diffWordsWithSpace","lineDiff","retLines","linesAndNewlines","line","newlineIsToken","trim","diffLines","diffTrimmedLines","sentenceDiff","diffSentences","cssDiff","diffCss","_typeof","obj","Symbol","iterator","constructor","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Object","from","o","minLen","n","toString","call","len","arr2","TypeError","objectPrototypeToString","jsonDiff","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","canonicalize","replace","diffJson","oldObj","newObj","stack","replacementStack","replacer","key","canonicalizedObj","toJSON","sortedKeys","_key","sort","arrayDiff","diffArrays","oldArr","newArr","parsePatch","uniDiff","diffstr","delimiters","match","list","parseIndex","index","header","parseFileHeader","hunks","_line","parseHunk","strict","Error","fileHeader","keyPrefix","data","fileName","substr","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation","distanceIterator","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","applyPatch","source","compareLine","lineNumber","patchContent","errorCount","fuzzFactor","offset","removeEOFNL","addEOFNL","hunkFits","toPos","j","content","diffOffset","_i","_hunk","_toPos","delimiter","previousOperation","_k","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","contextLines","entry","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","_curRange","prev","apply","_curRange2","_curRange3","contextSize","Math","min","oldEOFNewline","newEOFNewline","noNlBeforeAdds","formatPatch","createTwoFilesPatch","createPatch","arrayEqual","a","b","arrayStartsWith","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","merge","mine","theirs","base","loadPatch","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","Infinity","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","mergeLines","param","patch","conflict","check","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","state","matchChanges","changes","matchIndex","contextChanges","conflicted","change","reduce","removeChanges","delta","changeContent","forEach","myCount","theirCount","convertChangesToDMP","convertChangesToXML","escapeHTML","s"],"mappings":"AAAA,SAASA,IAAT,GAAgB,CAAE;;AAClBA,IAAI,CAACC,SAAL,GAAiB;AACfC,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAcC,SAAd,EAAyBC,SAAzB,EAAoC;AACxC,QAAIC,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;AACA,QAAIG,QAAQ,GAAGJ,OAAO,CAACI,QAAvB;;AAEA,QAAI,OAAOJ,OAAP,KAAmB,UAAvB,EAAmC;AACjCI,MAAAA,QAAQ,GAAGJ,OAAX;AACAA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,SAAKA,OAAL,GAAeA,OAAf;AACA,QAAIK,IAAI,GAAG,IAAX;;AAEA,aAASC,IAAT,CAAcC,KAAd,EAAqB;AACnB,UAAIH,QAAJ,EAAc;AACZI,QAAAA,UAAU,CAAC,YAAY;AACrBJ,UAAAA,QAAQ,CAACD,SAAD,EAAYI,KAAZ,CAAR;AACD,SAFS,EAEP,CAFO,CAAV;AAGA,eAAO,IAAP;AACD,OALD,MAKO;AACL,eAAOA,KAAP;AACD;AACF,KArBuC,CAqBtC;;;AAGFT,IAAAA,SAAS,GAAG,KAAKW,SAAL,CAAeX,SAAf,CAAZ;AACAC,IAAAA,SAAS,GAAG,KAAKU,SAAL,CAAeV,SAAf,CAAZ;AACAD,IAAAA,SAAS,GAAG,KAAKY,WAAL,CAAiB,KAAKC,QAAL,CAAcb,SAAd,CAAjB,CAAZ;AACAC,IAAAA,SAAS,GAAG,KAAKW,WAAL,CAAiB,KAAKC,QAAL,CAAcZ,SAAd,CAAjB,CAAZ;AACA,QAAIa,MAAM,GAAGb,SAAS,CAACG,MAAvB;AAAA,QACIW,MAAM,GAAGf,SAAS,CAACI,MADvB;AAEA,QAAIY,UAAU,GAAG,CAAjB;AACA,QAAIC,aAAa,GAAGH,MAAM,GAAGC,MAA7B;AACA,QAAIG,QAAQ,GAAG,CAAC;AACdC,MAAAA,MAAM,EAAE,CAAC,CADK;AAEdC,MAAAA,UAAU,EAAE;AAFE,KAAD,CAAf,CAhCwC,CAmCpC;;AAEJ,QAAIC,MAAM,GAAG,KAAKC,aAAL,CAAmBJ,QAAQ,CAAC,CAAD,CAA3B,EAAgCjB,SAAhC,EAA2CD,SAA3C,EAAsD,CAAtD,CAAb;;AAEA,QAAIkB,QAAQ,CAAC,CAAD,CAAR,CAAYC,MAAZ,GAAqB,CAArB,IAA0BL,MAA1B,IAAoCO,MAAM,GAAG,CAAT,IAAcN,MAAtD,EAA8D;AAC5D;AACA,aAAOP,IAAI,CAAC,CAAC;AACXC,QAAAA,KAAK,EAAE,KAAKc,IAAL,CAAUtB,SAAV,CADI;AAEXuB,QAAAA,KAAK,EAAEvB,SAAS,CAACG;AAFN,OAAD,CAAD,CAAX;AAID,KA7CuC,CA6CtC;;;AAGF,aAASqB,cAAT,GAA0B;AACxB,WAAK,IAAIC,YAAY,GAAG,CAAC,CAAD,GAAKV,UAA7B,EAAyCU,YAAY,IAAIV,UAAzD,EAAqEU,YAAY,IAAI,CAArF,EAAwF;AACtF,YAAIC,QAAQ,GAAG,KAAK,CAApB;;AAEA,YAAIC,OAAO,GAAGV,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CAAtB;AAAA,YACIG,UAAU,GAAGX,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CADzB;AAAA,YAEII,OAAO,GAAG,CAACD,UAAU,GAAGA,UAAU,CAACV,MAAd,GAAuB,CAAlC,IAAuCO,YAFrD;;AAIA,YAAIE,OAAJ,EAAa;AACX;AACAV,UAAAA,QAAQ,CAACQ,YAAY,GAAG,CAAhB,CAAR,GAA6BrB,SAA7B;AACD;;AAED,YAAI0B,MAAM,GAAGH,OAAO,IAAIA,OAAO,CAACT,MAAR,GAAiB,CAAjB,GAAqBL,MAA7C;AAAA,YACIkB,SAAS,GAAGH,UAAU,IAAI,KAAKC,OAAnB,IAA8BA,OAAO,GAAGf,MADxD;;AAGA,YAAI,CAACgB,MAAD,IAAW,CAACC,SAAhB,EAA2B;AACzB;AACAd,UAAAA,QAAQ,CAACQ,YAAD,CAAR,GAAyBrB,SAAzB;AACA;AACD,SAnBqF,CAmBpF;AACF;AACA;;;AAGA,YAAI,CAAC0B,MAAD,IAAWC,SAAS,IAAIJ,OAAO,CAACT,MAAR,GAAiBU,UAAU,CAACV,MAAxD,EAAgE;AAC9DQ,UAAAA,QAAQ,GAAGM,SAAS,CAACJ,UAAD,CAApB;AACAtB,UAAAA,IAAI,CAAC2B,aAAL,CAAmBP,QAAQ,CAACP,UAA5B,EAAwCf,SAAxC,EAAmD,IAAnD;AACD,SAHD,MAGO;AACLsB,UAAAA,QAAQ,GAAGC,OAAX,CADK,CACe;;AAEpBD,UAAAA,QAAQ,CAACR,MAAT;AACAZ,UAAAA,IAAI,CAAC2B,aAAL,CAAmBP,QAAQ,CAACP,UAA5B,EAAwC,IAAxC,EAA8Cf,SAA9C;AACD;;AAEDyB,QAAAA,OAAO,GAAGvB,IAAI,CAACe,aAAL,CAAmBK,QAAnB,EAA6B1B,SAA7B,EAAwCD,SAAxC,EAAmD0B,YAAnD,CAAV,CAlCsF,CAkCV;;AAE5E,YAAIC,QAAQ,CAACR,MAAT,GAAkB,CAAlB,IAAuBL,MAAvB,IAAiCgB,OAAO,GAAG,CAAV,IAAef,MAApD,EAA4D;AAC1D,iBAAOP,IAAI,CAAC2B,WAAW,CAAC5B,IAAD,EAAOoB,QAAQ,CAACP,UAAhB,EAA4BnB,SAA5B,EAAuCD,SAAvC,EAAkDO,IAAI,CAAC6B,eAAvD,CAAZ,CAAX;AACD,SAFD,MAEO;AACL;AACAlB,UAAAA,QAAQ,CAACQ,YAAD,CAAR,GAAyBC,QAAzB;AACD;AACF;;AAEDX,MAAAA,UAAU;AACX,KA9FuC,CA8FtC;AACF;AACA;;;AAGA,QAAIV,QAAJ,EAAc;AACZ,OAAC,SAAS+B,IAAT,GAAgB;AACf3B,QAAAA,UAAU,CAAC,YAAY;AACrB;;AAEA;AACA,cAAIM,UAAU,GAAGC,aAAjB,EAAgC;AAC9B,mBAAOX,QAAQ,EAAf;AACD;;AAED,cAAI,CAACmB,cAAc,EAAnB,EAAuB;AACrBY,YAAAA,IAAI;AACL;AACF,SAXS,EAWP,CAXO,CAAV;AAYD,OAbD;AAcD,KAfD,MAeO;AACL,aAAOrB,UAAU,IAAIC,aAArB,EAAoC;AAClC,YAAIqB,GAAG,GAAGb,cAAc,EAAxB;;AAEA,YAAIa,GAAJ,EAAS;AACP,iBAAOA,GAAP;AACD;AACF;AACF;AACF,GA5Hc;AA6HfJ,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBd,UAAvB,EAAmCmB,KAAnC,EAA0CC,OAA1C,EAAmD;AAChE,QAAIC,IAAI,GAAGrB,UAAU,CAACA,UAAU,CAAChB,MAAX,GAAoB,CAArB,CAArB;;AAEA,QAAIqC,IAAI,IAAIA,IAAI,CAACF,KAAL,KAAeA,KAAvB,IAAgCE,IAAI,CAACD,OAAL,KAAiBA,OAArD,EAA8D;AAC5D;AACA;AACApB,MAAAA,UAAU,CAACA,UAAU,CAAChB,MAAX,GAAoB,CAArB,CAAV,GAAoC;AAClCoB,QAAAA,KAAK,EAAEiB,IAAI,CAACjB,KAAL,GAAa,CADc;AAElCe,QAAAA,KAAK,EAAEA,KAF2B;AAGlCC,QAAAA,OAAO,EAAEA;AAHyB,OAApC;AAKD,KARD,MAQO;AACLpB,MAAAA,UAAU,CAACsB,IAAX,CAAgB;AACdlB,QAAAA,KAAK,EAAE,CADO;AAEde,QAAAA,KAAK,EAAEA,KAFO;AAGdC,QAAAA,OAAO,EAAEA;AAHK,OAAhB;AAKD;AACF,GA/Ic;AAgJflB,EAAAA,aAAa,EAAE,SAASA,aAAT,CAAuBK,QAAvB,EAAiC1B,SAAjC,EAA4CD,SAA5C,EAAuD0B,YAAvD,EAAqE;AAClF,QAAIZ,MAAM,GAAGb,SAAS,CAACG,MAAvB;AAAA,QACIW,MAAM,GAAGf,SAAS,CAACI,MADvB;AAAA,QAEIe,MAAM,GAAGQ,QAAQ,CAACR,MAFtB;AAAA,QAGIE,MAAM,GAAGF,MAAM,GAAGO,YAHtB;AAAA,QAIIiB,WAAW,GAAG,CAJlB;;AAMA,WAAOxB,MAAM,GAAG,CAAT,GAAaL,MAAb,IAAuBO,MAAM,GAAG,CAAT,GAAaN,MAApC,IAA8C,KAAK6B,MAAL,CAAY3C,SAAS,CAACkB,MAAM,GAAG,CAAV,CAArB,EAAmCnB,SAAS,CAACqB,MAAM,GAAG,CAAV,CAA5C,CAArD,EAAgH;AAC9GF,MAAAA,MAAM;AACNE,MAAAA,MAAM;AACNsB,MAAAA,WAAW;AACZ;;AAED,QAAIA,WAAJ,EAAiB;AACfhB,MAAAA,QAAQ,CAACP,UAAT,CAAoBsB,IAApB,CAAyB;AACvBlB,QAAAA,KAAK,EAAEmB;AADgB,OAAzB;AAGD;;AAEDhB,IAAAA,QAAQ,CAACR,MAAT,GAAkBA,MAAlB;AACA,WAAOE,MAAP;AACD,GArKc;AAsKfuB,EAAAA,MAAM,EAAE,SAASA,MAAT,CAAgBC,IAAhB,EAAsBC,KAAtB,EAA6B;AACnC,QAAI,KAAK5C,OAAL,CAAa6C,UAAjB,EAA6B;AAC3B,aAAO,KAAK7C,OAAL,CAAa6C,UAAb,CAAwBF,IAAxB,EAA8BC,KAA9B,CAAP;AACD,KAFD,MAEO;AACL,aAAOD,IAAI,KAAKC,KAAT,IAAkB,KAAK5C,OAAL,CAAa8C,UAAb,IAA2BH,IAAI,CAACI,WAAL,OAAuBH,KAAK,CAACG,WAAN,EAA3E;AACD;AACF,GA5Kc;AA6KfrC,EAAAA,WAAW,EAAE,SAASA,WAAT,CAAqBsC,KAArB,EAA4B;AACvC,QAAIZ,GAAG,GAAG,EAAV;;AAEA,SAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAAC9C,MAA1B,EAAkC+C,CAAC,EAAnC,EAAuC;AACrC,UAAID,KAAK,CAACC,CAAD,CAAT,EAAc;AACZb,QAAAA,GAAG,CAACI,IAAJ,CAASQ,KAAK,CAACC,CAAD,CAAd;AACD;AACF;;AAED,WAAOb,GAAP;AACD,GAvLc;AAwLf3B,EAAAA,SAAS,EAAE,SAASA,SAAT,CAAmBF,KAAnB,EAA0B;AACnC,WAAOA,KAAP;AACD,GA1Lc;AA2LfI,EAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkBJ,KAAlB,EAAyB;AACjC,WAAOA,KAAK,CAAC2C,KAAN,CAAY,EAAZ,CAAP;AACD,GA7Lc;AA8Lf7B,EAAAA,IAAI,EAAE,SAASA,IAAT,CAAc8B,KAAd,EAAqB;AACzB,WAAOA,KAAK,CAAC9B,IAAN,CAAW,EAAX,CAAP;AACD;AAhMc,CAAjB;;AAmMA,SAASY,WAAT,CAAqBpC,IAArB,EAA2BqB,UAA3B,EAAuCnB,SAAvC,EAAkDD,SAAlD,EAA6DoC,eAA7D,EAA8E;AAC5E,MAAIkB,YAAY,GAAG,CAAnB;AAAA,MACIC,YAAY,GAAGnC,UAAU,CAAChB,MAD9B;AAAA,MAEIe,MAAM,GAAG,CAFb;AAAA,MAGIE,MAAM,GAAG,CAHb;;AAKA,SAAOiC,YAAY,GAAGC,YAAtB,EAAoCD,YAAY,EAAhD,EAAoD;AAClD,QAAIE,SAAS,GAAGpC,UAAU,CAACkC,YAAD,CAA1B;;AAEA,QAAI,CAACE,SAAS,CAAChB,OAAf,EAAwB;AACtB,UAAI,CAACgB,SAAS,CAACjB,KAAX,IAAoBH,eAAxB,EAAyC;AACvC,YAAI3B,KAAK,GAAGR,SAAS,CAACwD,KAAV,CAAgBtC,MAAhB,EAAwBA,MAAM,GAAGqC,SAAS,CAAChC,KAA3C,CAAZ;AACAf,QAAAA,KAAK,GAAGA,KAAK,CAACiD,GAAN,CAAU,UAAUjD,KAAV,EAAiB0C,CAAjB,EAAoB;AACpC,cAAIQ,QAAQ,GAAG3D,SAAS,CAACqB,MAAM,GAAG8B,CAAV,CAAxB;AACA,iBAAOQ,QAAQ,CAACvD,MAAT,GAAkBK,KAAK,CAACL,MAAxB,GAAiCuD,QAAjC,GAA4ClD,KAAnD;AACD,SAHO,CAAR;AAIA+C,QAAAA,SAAS,CAAC/C,KAAV,GAAkBV,IAAI,CAACwB,IAAL,CAAUd,KAAV,CAAlB;AACD,OAPD,MAOO;AACL+C,QAAAA,SAAS,CAAC/C,KAAV,GAAkBV,IAAI,CAACwB,IAAL,CAAUtB,SAAS,CAACwD,KAAV,CAAgBtC,MAAhB,EAAwBA,MAAM,GAAGqC,SAAS,CAAChC,KAA3C,CAAV,CAAlB;AACD;;AAEDL,MAAAA,MAAM,IAAIqC,SAAS,CAAChC,KAApB,CAZsB,CAYK;;AAE3B,UAAI,CAACgC,SAAS,CAACjB,KAAf,EAAsB;AACpBlB,QAAAA,MAAM,IAAImC,SAAS,CAAChC,KAApB;AACD;AACF,KAjBD,MAiBO;AACLgC,MAAAA,SAAS,CAAC/C,KAAV,GAAkBV,IAAI,CAACwB,IAAL,CAAUvB,SAAS,CAACyD,KAAV,CAAgBpC,MAAhB,EAAwBA,MAAM,GAAGmC,SAAS,CAAChC,KAA3C,CAAV,CAAlB;AACAH,MAAAA,MAAM,IAAImC,SAAS,CAAChC,KAApB,CAFK,CAEsB;AAC3B;AACA;;AAEA,UAAI8B,YAAY,IAAIlC,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAAV,CAA6Bf,KAAjD,EAAwD;AACtD,YAAIqB,GAAG,GAAGxC,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAApB;AACAlC,QAAAA,UAAU,CAACkC,YAAY,GAAG,CAAhB,CAAV,GAA+BlC,UAAU,CAACkC,YAAD,CAAzC;AACAlC,QAAAA,UAAU,CAACkC,YAAD,CAAV,GAA2BM,GAA3B;AACD;AACF;AACF,GAtC2E,CAsC1E;AACF;AACA;;;AAGA,MAAIC,aAAa,GAAGzC,UAAU,CAACmC,YAAY,GAAG,CAAhB,CAA9B;;AAEA,MAAIA,YAAY,GAAG,CAAf,IAAoB,OAAOM,aAAa,CAACpD,KAArB,KAA+B,QAAnD,KAAgEoD,aAAa,CAACtB,KAAd,IAAuBsB,aAAa,CAACrB,OAArG,KAAiHzC,IAAI,CAAC6C,MAAL,CAAY,EAAZ,EAAgBiB,aAAa,CAACpD,KAA9B,CAArH,EAA2J;AACzJW,IAAAA,UAAU,CAACmC,YAAY,GAAG,CAAhB,CAAV,CAA6B9C,KAA7B,IAAsCoD,aAAa,CAACpD,KAApD;AACAW,IAAAA,UAAU,CAAC0C,GAAX;AACD;;AAED,SAAO1C,UAAP;AACD;;AAED,SAASa,SAAT,CAAmB8B,IAAnB,EAAyB;AACvB,SAAO;AACL5C,IAAAA,MAAM,EAAE4C,IAAI,CAAC5C,MADR;AAELC,IAAAA,UAAU,EAAE2C,IAAI,CAAC3C,UAAL,CAAgBqC,KAAhB,CAAsB,CAAtB;AAFP,GAAP;AAID;;AAED,IAAIO,aAAa,GAAG,IAAInE,IAAJ,EAApB;;AACA,SAASoE,SAAT,CAAmBC,MAAnB,EAA2BC,MAA3B,EAAmCjE,OAAnC,EAA4C;AAC1C,SAAO8D,aAAa,CAACjE,IAAd,CAAmBmE,MAAnB,EAA2BC,MAA3B,EAAmCjE,OAAnC,CAAP;AACD;;AAED,SAASkE,eAAT,CAAyBlE,OAAzB,EAAkCmE,QAAlC,EAA4C;AAC1C,MAAI,OAAOnE,OAAP,KAAmB,UAAvB,EAAmC;AACjCmE,IAAAA,QAAQ,CAAC/D,QAAT,GAAoBJ,OAApB;AACD,GAFD,MAEO,IAAIA,OAAJ,EAAa;AAClB,SAAK,IAAIoE,IAAT,IAAiBpE,OAAjB,EAA0B;AACxB;AACA,UAAIA,OAAO,CAACqE,cAAR,CAAuBD,IAAvB,CAAJ,EAAkC;AAChCD,QAAAA,QAAQ,CAACC,IAAD,CAAR,GAAiBpE,OAAO,CAACoE,IAAD,CAAxB;AACD;AACF;AACF;;AAED,SAAOD,QAAP;AACD,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAIG,iBAAiB,GAAG,+DAAxB;AACA,IAAIC,YAAY,GAAG,IAAnB;AACA,IAAIC,QAAQ,GAAG,IAAI7E,IAAJ,EAAf;;AAEA6E,QAAQ,CAAC9B,MAAT,GAAkB,UAAUC,IAAV,EAAgBC,KAAhB,EAAuB;AACvC,MAAI,KAAK5C,OAAL,CAAa8C,UAAjB,EAA6B;AAC3BH,IAAAA,IAAI,GAAGA,IAAI,CAACI,WAAL,EAAP;AACAH,IAAAA,KAAK,GAAGA,KAAK,CAACG,WAAN,EAAR;AACD;;AAED,SAAOJ,IAAI,KAAKC,KAAT,IAAkB,KAAK5C,OAAL,CAAayE,gBAAb,IAAiC,CAACF,YAAY,CAACG,IAAb,CAAkB/B,IAAlB,CAAlC,IAA6D,CAAC4B,YAAY,CAACG,IAAb,CAAkB9B,KAAlB,CAAvF;AACD,CAPD;;AASA4B,QAAQ,CAAC7D,QAAT,GAAoB,UAAUJ,KAAV,EAAiB;AACnC;AACA,MAAIoE,MAAM,GAAGpE,KAAK,CAAC2C,KAAN,CAAY,iCAAZ,CAAb,CAFmC,CAE0B;;AAE7D,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0B,MAAM,CAACzE,MAAP,GAAgB,CAApC,EAAuC+C,CAAC,EAAxC,EAA4C;AAC1C;AACA,QAAI,CAAC0B,MAAM,CAAC1B,CAAC,GAAG,CAAL,CAAP,IAAkB0B,MAAM,CAAC1B,CAAC,GAAG,CAAL,CAAxB,IAAmCqB,iBAAiB,CAACI,IAAlB,CAAuBC,MAAM,CAAC1B,CAAD,CAA7B,CAAnC,IAAwEqB,iBAAiB,CAACI,IAAlB,CAAuBC,MAAM,CAAC1B,CAAC,GAAG,CAAL,CAA7B,CAA5E,EAAmH;AACjH0B,MAAAA,MAAM,CAAC1B,CAAD,CAAN,IAAa0B,MAAM,CAAC1B,CAAC,GAAG,CAAL,CAAnB;AACA0B,MAAAA,MAAM,CAACC,MAAP,CAAc3B,CAAC,GAAG,CAAlB,EAAqB,CAArB;AACAA,MAAAA,CAAC;AACF;AACF;;AAED,SAAO0B,MAAP;AACD,CAdD;;AAgBA,SAASE,SAAT,CAAmBb,MAAnB,EAA2BC,MAA3B,EAAmCjE,OAAnC,EAA4C;AAC1CA,EAAAA,OAAO,GAAGkE,eAAe,CAAClE,OAAD,EAAU;AACjCyE,IAAAA,gBAAgB,EAAE;AADe,GAAV,CAAzB;AAGA,SAAOD,QAAQ,CAAC3E,IAAT,CAAcmE,MAAd,EAAsBC,MAAtB,EAA8BjE,OAA9B,CAAP;AACD;;AACD,SAAS8E,kBAAT,CAA4Bd,MAA5B,EAAoCC,MAApC,EAA4CjE,OAA5C,EAAqD;AACnD,SAAOwE,QAAQ,CAAC3E,IAAT,CAAcmE,MAAd,EAAsBC,MAAtB,EAA8BjE,OAA9B,CAAP;AACD;;AAED,IAAI+E,QAAQ,GAAG,IAAIpF,IAAJ,EAAf;;AAEAoF,QAAQ,CAACpE,QAAT,GAAoB,UAAUJ,KAAV,EAAiB;AACnC,MAAIyE,QAAQ,GAAG,EAAf;AAAA,MACIC,gBAAgB,GAAG1E,KAAK,CAAC2C,KAAN,CAAY,WAAZ,CADvB,CADmC,CAEc;;AAEjD,MAAI,CAAC+B,gBAAgB,CAACA,gBAAgB,CAAC/E,MAAjB,GAA0B,CAA3B,CAArB,EAAoD;AAClD+E,IAAAA,gBAAgB,CAACrB,GAAjB;AACD,GANkC,CAMjC;;;AAGF,OAAK,IAAIX,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgC,gBAAgB,CAAC/E,MAArC,EAA6C+C,CAAC,EAA9C,EAAkD;AAChD,QAAIiC,IAAI,GAAGD,gBAAgB,CAAChC,CAAD,CAA3B;;AAEA,QAAIA,CAAC,GAAG,CAAJ,IAAS,CAAC,KAAKjD,OAAL,CAAamF,cAA3B,EAA2C;AACzCH,MAAAA,QAAQ,CAACA,QAAQ,CAAC9E,MAAT,GAAkB,CAAnB,CAAR,IAAiCgF,IAAjC;AACD,KAFD,MAEO;AACL,UAAI,KAAKlF,OAAL,CAAayE,gBAAjB,EAAmC;AACjCS,QAAAA,IAAI,GAAGA,IAAI,CAACE,IAAL,EAAP;AACD;;AAEDJ,MAAAA,QAAQ,CAACxC,IAAT,CAAc0C,IAAd;AACD;AACF;;AAED,SAAOF,QAAP;AACD,CAxBD;;AA0BA,SAASK,SAAT,CAAmBrB,MAAnB,EAA2BC,MAA3B,EAAmC7D,QAAnC,EAA6C;AAC3C,SAAO2E,QAAQ,CAAClF,IAAT,CAAcmE,MAAd,EAAsBC,MAAtB,EAA8B7D,QAA9B,CAAP;AACD;;AACD,SAASkF,gBAAT,CAA0BtB,MAA1B,EAAkCC,MAAlC,EAA0C7D,QAA1C,EAAoD;AAClD,MAAIJ,OAAO,GAAGkE,eAAe,CAAC9D,QAAD,EAAW;AACtCqE,IAAAA,gBAAgB,EAAE;AADoB,GAAX,CAA7B;AAGA,SAAOM,QAAQ,CAAClF,IAAT,CAAcmE,MAAd,EAAsBC,MAAtB,EAA8BjE,OAA9B,CAAP;AACD;;AAED,IAAIuF,YAAY,GAAG,IAAI5F,IAAJ,EAAnB;;AAEA4F,YAAY,CAAC5E,QAAb,GAAwB,UAAUJ,KAAV,EAAiB;AACvC,SAAOA,KAAK,CAAC2C,KAAN,CAAY,uBAAZ,CAAP;AACD,CAFD;;AAIA,SAASsC,aAAT,CAAuBxB,MAAvB,EAA+BC,MAA/B,EAAuC7D,QAAvC,EAAiD;AAC/C,SAAOmF,YAAY,CAAC1F,IAAb,CAAkBmE,MAAlB,EAA0BC,MAA1B,EAAkC7D,QAAlC,CAAP;AACD;;AAED,IAAIqF,OAAO,GAAG,IAAI9F,IAAJ,EAAd;;AAEA8F,OAAO,CAAC9E,QAAR,GAAmB,UAAUJ,KAAV,EAAiB;AAClC,SAAOA,KAAK,CAAC2C,KAAN,CAAY,eAAZ,CAAP;AACD,CAFD;;AAIA,SAASwC,OAAT,CAAiB1B,MAAjB,EAAyBC,MAAzB,EAAiC7D,QAAjC,EAA2C;AACzC,SAAOqF,OAAO,CAAC5F,IAAR,CAAamE,MAAb,EAAqBC,MAArB,EAA6B7D,QAA7B,CAAP;AACD;;AAED,SAASuF,OAAT,CAAiBC,GAAjB,EAAsB;AACpB;;AAEA,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AACvEH,IAAAA,OAAO,GAAG,UAAUC,GAAV,EAAe;AACvB,aAAO,OAAOA,GAAd;AACD,KAFD;AAGD,GAJD,MAIO;AACLD,IAAAA,OAAO,GAAG,UAAUC,GAAV,EAAe;AACvB,aAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACjG,SAApF,GAAgG,QAAhG,GAA2G,OAAOgG,GAAzH;AACD,KAFD;AAGD;;AAED,SAAOD,OAAO,CAACC,GAAD,CAAd;AACD;;AAED,SAASI,kBAAT,CAA4BC,GAA5B,EAAiC;AAC/B,SAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,2BAA2B,CAACH,GAAD,CAA/E,IAAwFI,kBAAkB,EAAjH;AACD;;AAED,SAASH,kBAAT,CAA4BD,GAA5B,EAAiC;AAC/B,MAAIK,KAAK,CAACC,OAAN,CAAcN,GAAd,CAAJ,EAAwB,OAAOO,iBAAiB,CAACP,GAAD,CAAxB;AACzB;;AAED,SAASE,gBAAT,CAA0BM,IAA1B,EAAgC;AAC9B,MAAI,OAAOZ,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,QAAP,IAAmBY,MAAM,CAACD,IAAD,CAA9D,EAAsE,OAAOH,KAAK,CAACK,IAAN,CAAWF,IAAX,CAAP;AACvE;;AAED,SAASL,2BAAT,CAAqCQ,CAArC,EAAwCC,MAAxC,EAAgD;AAC9C,MAAI,CAACD,CAAL,EAAQ;AACR,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOJ,iBAAiB,CAACI,CAAD,EAAIC,MAAJ,CAAxB;AAC3B,MAAIC,CAAC,GAAGJ,MAAM,CAAC9G,SAAP,CAAiBmH,QAAjB,CAA0BC,IAA1B,CAA+BJ,CAA/B,EAAkCrD,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AACA,MAAIuD,CAAC,KAAK,QAAN,IAAkBF,CAAC,CAACb,WAAxB,EAAqCe,CAAC,GAAGF,CAAC,CAACb,WAAF,CAAc3B,IAAlB;AACrC,MAAI0C,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOR,KAAK,CAACK,IAAN,CAAWC,CAAX,CAAP;AAChC,MAAIE,CAAC,KAAK,WAAN,IAAqB,2CAA2CpC,IAA3C,CAAgDoC,CAAhD,CAAzB,EAA6E,OAAON,iBAAiB,CAACI,CAAD,EAAIC,MAAJ,CAAxB;AAC9E;;AAED,SAASL,iBAAT,CAA2BP,GAA3B,EAAgCgB,GAAhC,EAAqC;AACnC,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGhB,GAAG,CAAC/F,MAA7B,EAAqC+G,GAAG,GAAGhB,GAAG,CAAC/F,MAAV;;AAErC,OAAK,IAAI+C,CAAC,GAAG,CAAR,EAAWiE,IAAI,GAAG,IAAIZ,KAAJ,CAAUW,GAAV,CAAvB,EAAuChE,CAAC,GAAGgE,GAA3C,EAAgDhE,CAAC,EAAjD,EAAqDiE,IAAI,CAACjE,CAAD,CAAJ,GAAUgD,GAAG,CAAChD,CAAD,CAAb;;AAErD,SAAOiE,IAAP;AACD;;AAED,SAASb,kBAAT,GAA8B;AAC5B,QAAM,IAAIc,SAAJ,CAAc,sIAAd,CAAN;AACD;;AAED,IAAIC,uBAAuB,GAAGV,MAAM,CAAC9G,SAAP,CAAiBmH,QAA/C;AACA,IAAIM,QAAQ,GAAG,IAAI1H,IAAJ,EAAf,C,CAA2B;AAC3B;;AAEA0H,QAAQ,CAACnF,eAAT,GAA2B,IAA3B;AACAmF,QAAQ,CAAC1G,QAAT,GAAoBoE,QAAQ,CAACpE,QAA7B;;AAEA0G,QAAQ,CAAC5G,SAAT,GAAqB,UAAUF,KAAV,EAAiB;AACpC,MAAI+G,aAAa,GAAG,KAAKtH,OAAzB;AAAA,MACIuH,oBAAoB,GAAGD,aAAa,CAACC,oBADzC;AAAA,MAEIC,qBAAqB,GAAGF,aAAa,CAACG,iBAF1C;AAAA,MAGIA,iBAAiB,GAAGD,qBAAqB,KAAK,KAAK,CAA/B,GAAmC,UAAUE,CAAV,EAAaC,CAAb,EAAgB;AACzE,WAAO,OAAOA,CAAP,KAAa,WAAb,GAA2BJ,oBAA3B,GAAkDI,CAAzD;AACD,GAFuB,GAEpBH,qBALJ;AAMA,SAAO,OAAOjH,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCqH,IAAI,CAACC,SAAL,CAAeC,YAAY,CAACvH,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoBkH,iBAApB,CAA3B,EAAmEA,iBAAnE,EAAsF,IAAtF,CAA3C;AACD,CARD;;AAUAJ,QAAQ,CAAC3E,MAAT,GAAkB,UAAUC,IAAV,EAAgBC,KAAhB,EAAuB;AACvC,SAAOjD,IAAI,CAACC,SAAL,CAAe8C,MAAf,CAAsBsE,IAAtB,CAA2BK,QAA3B,EAAqC1E,IAAI,CAACoF,OAAL,CAAa,YAAb,EAA2B,IAA3B,CAArC,EAAuEnF,KAAK,CAACmF,OAAN,CAAc,YAAd,EAA4B,IAA5B,CAAvE,CAAP;AACD,CAFD;;AAIA,SAASC,QAAT,CAAkBC,MAAlB,EAA0BC,MAA1B,EAAkClI,OAAlC,EAA2C;AACzC,SAAOqH,QAAQ,CAACxH,IAAT,CAAcoI,MAAd,EAAsBC,MAAtB,EAA8BlI,OAA9B,CAAP;AACD,C,CAAC;AACF;;;AAEA,SAAS8H,YAAT,CAAsBlC,GAAtB,EAA2BuC,KAA3B,EAAkCC,gBAAlC,EAAoDC,QAApD,EAA8DC,GAA9D,EAAmE;AACjEH,EAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;AACAC,EAAAA,gBAAgB,GAAGA,gBAAgB,IAAI,EAAvC;;AAEA,MAAIC,QAAJ,EAAc;AACZzC,IAAAA,GAAG,GAAGyC,QAAQ,CAACC,GAAD,EAAM1C,GAAN,CAAd;AACD;;AAED,MAAI3C,CAAJ;;AAEA,OAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkF,KAAK,CAACjI,MAAtB,EAA8B+C,CAAC,IAAI,CAAnC,EAAsC;AACpC,QAAIkF,KAAK,CAAClF,CAAD,CAAL,KAAa2C,GAAjB,EAAsB;AACpB,aAAOwC,gBAAgB,CAACnF,CAAD,CAAvB;AACD;AACF;;AAED,MAAIsF,gBAAJ;;AAEA,MAAI,qBAAqBnB,uBAAuB,CAACJ,IAAxB,CAA6BpB,GAA7B,CAAzB,EAA4D;AAC1DuC,IAAAA,KAAK,CAAC3F,IAAN,CAAWoD,GAAX;AACA2C,IAAAA,gBAAgB,GAAG,IAAIjC,KAAJ,CAAUV,GAAG,CAAC1F,MAAd,CAAnB;AACAkI,IAAAA,gBAAgB,CAAC5F,IAAjB,CAAsB+F,gBAAtB;;AAEA,SAAKtF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG2C,GAAG,CAAC1F,MAApB,EAA4B+C,CAAC,IAAI,CAAjC,EAAoC;AAClCsF,MAAAA,gBAAgB,CAACtF,CAAD,CAAhB,GAAsB6E,YAAY,CAAClC,GAAG,CAAC3C,CAAD,CAAJ,EAASkF,KAAT,EAAgBC,gBAAhB,EAAkCC,QAAlC,EAA4CC,GAA5C,CAAlC;AACD;;AAEDH,IAAAA,KAAK,CAACvE,GAAN;AACAwE,IAAAA,gBAAgB,CAACxE,GAAjB;AACA,WAAO2E,gBAAP;AACD;;AAED,MAAI3C,GAAG,IAAIA,GAAG,CAAC4C,MAAf,EAAuB;AACrB5C,IAAAA,GAAG,GAAGA,GAAG,CAAC4C,MAAJ,EAAN;AACD;;AAED,MAAI7C,OAAO,CAACC,GAAD,CAAP,KAAiB,QAAjB,IAA6BA,GAAG,KAAK,IAAzC,EAA+C;AAC7CuC,IAAAA,KAAK,CAAC3F,IAAN,CAAWoD,GAAX;AACA2C,IAAAA,gBAAgB,GAAG,EAAnB;AACAH,IAAAA,gBAAgB,CAAC5F,IAAjB,CAAsB+F,gBAAtB;;AAEA,QAAIE,UAAU,GAAG,EAAjB;AAAA,QACIC,IADJ;;AAGA,SAAKA,IAAL,IAAa9C,GAAb,EAAkB;AAChB;AACA,UAAIA,GAAG,CAACvB,cAAJ,CAAmBqE,IAAnB,CAAJ,EAA8B;AAC5BD,QAAAA,UAAU,CAACjG,IAAX,CAAgBkG,IAAhB;AACD;AACF;;AAEDD,IAAAA,UAAU,CAACE,IAAX;;AAEA,SAAK1F,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGwF,UAAU,CAACvI,MAA3B,EAAmC+C,CAAC,IAAI,CAAxC,EAA2C;AACzCyF,MAAAA,IAAI,GAAGD,UAAU,CAACxF,CAAD,CAAjB;AACAsF,MAAAA,gBAAgB,CAACG,IAAD,CAAhB,GAAyBZ,YAAY,CAAClC,GAAG,CAAC8C,IAAD,CAAJ,EAAYP,KAAZ,EAAmBC,gBAAnB,EAAqCC,QAArC,EAA+CK,IAA/C,CAArC;AACD;;AAEDP,IAAAA,KAAK,CAACvE,GAAN;AACAwE,IAAAA,gBAAgB,CAACxE,GAAjB;AACD,GAxBD,MAwBO;AACL2E,IAAAA,gBAAgB,GAAG3C,GAAnB;AACD;;AAED,SAAO2C,gBAAP;AACD;;AAED,IAAIK,SAAS,GAAG,IAAIjJ,IAAJ,EAAhB;;AAEAiJ,SAAS,CAACjI,QAAV,GAAqB,UAAUJ,KAAV,EAAiB;AACpC,SAAOA,KAAK,CAACgD,KAAN,EAAP;AACD,CAFD;;AAIAqF,SAAS,CAACvH,IAAV,GAAiBuH,SAAS,CAAClI,WAAV,GAAwB,UAAUH,KAAV,EAAiB;AACxD,SAAOA,KAAP;AACD,CAFD;;AAIA,SAASsI,UAAT,CAAoBC,MAApB,EAA4BC,MAA5B,EAAoC3I,QAApC,EAA8C;AAC5C,SAAOwI,SAAS,CAAC/I,IAAV,CAAeiJ,MAAf,EAAuBC,MAAvB,EAA+B3I,QAA/B,CAAP;AACD;;AAED,SAAS4I,UAAT,CAAoBC,OAApB,EAA6B;AAC3B,MAAIjJ,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;AACA,MAAIiJ,OAAO,GAAGD,OAAO,CAAC/F,KAAR,CAAc,qBAAd,CAAd;AAAA,MACIiG,UAAU,GAAGF,OAAO,CAACG,KAAR,CAAc,sBAAd,KAAyC,EAD1D;AAAA,MAEIC,IAAI,GAAG,EAFX;AAAA,MAGIpG,CAAC,GAAG,CAHR;;AAKA,WAASqG,UAAT,GAAsB;AACpB,QAAIC,KAAK,GAAG,EAAZ;AACAF,IAAAA,IAAI,CAAC7G,IAAL,CAAU+G,KAAV,EAFoB,CAEF;;AAElB,WAAOtG,CAAC,GAAGiG,OAAO,CAAChJ,MAAnB,EAA2B;AACzB,UAAIgF,IAAI,GAAGgE,OAAO,CAACjG,CAAD,CAAlB,CADyB,CACF;;AAEvB,UAAI,wBAAwByB,IAAxB,CAA6BQ,IAA7B,CAAJ,EAAwC;AACtC;AACD,OALwB,CAKvB;;;AAGF,UAAIsE,MAAM,GAAG,2CAA2CrH,IAA3C,CAAgD+C,IAAhD,CAAb;;AAEA,UAAIsE,MAAJ,EAAY;AACVD,QAAAA,KAAK,CAACA,KAAN,GAAcC,MAAM,CAAC,CAAD,CAApB;AACD;;AAEDvG,MAAAA,CAAC;AACF,KAnBmB,CAmBlB;AACF;;;AAGAwG,IAAAA,eAAe,CAACF,KAAD,CAAf;AACAE,IAAAA,eAAe,CAACF,KAAD,CAAf,CAxBoB,CAwBI;;AAExBA,IAAAA,KAAK,CAACG,KAAN,GAAc,EAAd;;AAEA,WAAOzG,CAAC,GAAGiG,OAAO,CAAChJ,MAAnB,EAA2B;AACzB,UAAIyJ,KAAK,GAAGT,OAAO,CAACjG,CAAD,CAAnB;;AAEA,UAAI,iCAAiCyB,IAAjC,CAAsCiF,KAAtC,CAAJ,EAAkD;AAChD;AACD,OAFD,MAEO,IAAI,MAAMjF,IAAN,CAAWiF,KAAX,CAAJ,EAAuB;AAC5BJ,QAAAA,KAAK,CAACG,KAAN,CAAYlH,IAAZ,CAAiBoH,SAAS,EAA1B;AACD,OAFM,MAEA,IAAID,KAAK,IAAI3J,OAAO,CAAC6J,MAArB,EAA6B;AAClC;AACA,cAAM,IAAIC,KAAJ,CAAU,mBAAmB7G,CAAC,GAAG,CAAvB,IAA4B,GAA5B,GAAkC2E,IAAI,CAACC,SAAL,CAAe8B,KAAf,CAA5C,CAAN;AACD,OAHM,MAGA;AACL1G,QAAAA,CAAC;AACF;AACF;AACF,GAjD0B,CAiDzB;AACF;;;AAGA,WAASwG,eAAT,CAAyBF,KAAzB,EAAgC;AAC9B,QAAIQ,UAAU,GAAG,wBAAwB5H,IAAxB,CAA6B+G,OAAO,CAACjG,CAAD,CAApC,CAAjB;;AAEA,QAAI8G,UAAJ,EAAgB;AACd,UAAIC,SAAS,GAAGD,UAAU,CAAC,CAAD,CAAV,KAAkB,KAAlB,GAA0B,KAA1B,GAAkC,KAAlD;AACA,UAAIE,IAAI,GAAGF,UAAU,CAAC,CAAD,CAAV,CAAc7G,KAAd,CAAoB,IAApB,EAA0B,CAA1B,CAAX;AACA,UAAIgH,QAAQ,GAAGD,IAAI,CAAC,CAAD,CAAJ,CAAQlC,OAAR,CAAgB,OAAhB,EAAyB,IAAzB,CAAf;;AAEA,UAAI,SAASrD,IAAT,CAAcwF,QAAd,CAAJ,EAA6B;AAC3BA,QAAAA,QAAQ,GAAGA,QAAQ,CAACC,MAAT,CAAgB,CAAhB,EAAmBD,QAAQ,CAAChK,MAAT,GAAkB,CAArC,CAAX;AACD;;AAEDqJ,MAAAA,KAAK,CAACS,SAAS,GAAG,UAAb,CAAL,GAAgCE,QAAhC;AACAX,MAAAA,KAAK,CAACS,SAAS,GAAG,QAAb,CAAL,GAA8B,CAACC,IAAI,CAAC,CAAD,CAAJ,IAAW,EAAZ,EAAgB7E,IAAhB,EAA9B;AACAnC,MAAAA,CAAC;AACF;AACF,GArE0B,CAqEzB;AACF;;;AAGA,WAAS2G,SAAT,GAAqB;AACnB,QAAIQ,gBAAgB,GAAGnH,CAAvB;AAAA,QACIoH,eAAe,GAAGnB,OAAO,CAACjG,CAAC,EAAF,CAD7B;AAAA,QAEIqH,WAAW,GAAGD,eAAe,CAACnH,KAAhB,CAAsB,4CAAtB,CAFlB;AAGA,QAAIqH,IAAI,GAAG;AACTC,MAAAA,QAAQ,EAAE,CAACF,WAAW,CAAC,CAAD,CADb;AAETG,MAAAA,QAAQ,EAAE,OAAOH,WAAW,CAAC,CAAD,CAAlB,KAA0B,WAA1B,GAAwC,CAAxC,GAA4C,CAACA,WAAW,CAAC,CAAD,CAFzD;AAGTI,MAAAA,QAAQ,EAAE,CAACJ,WAAW,CAAC,CAAD,CAHb;AAITK,MAAAA,QAAQ,EAAE,OAAOL,WAAW,CAAC,CAAD,CAAlB,KAA0B,WAA1B,GAAwC,CAAxC,GAA4C,CAACA,WAAW,CAAC,CAAD,CAJzD;AAKTM,MAAAA,KAAK,EAAE,EALE;AAMTC,MAAAA,cAAc,EAAE;AANP,KAAX,CAJmB,CAWhB;AACH;AACA;;AAEA,QAAIN,IAAI,CAACE,QAAL,KAAkB,CAAtB,EAAyB;AACvBF,MAAAA,IAAI,CAACC,QAAL,IAAiB,CAAjB;AACD;;AAED,QAAID,IAAI,CAACI,QAAL,KAAkB,CAAtB,EAAyB;AACvBJ,MAAAA,IAAI,CAACG,QAAL,IAAiB,CAAjB;AACD;;AAED,QAAII,QAAQ,GAAG,CAAf;AAAA,QACIC,WAAW,GAAG,CADlB;;AAGA,WAAO9H,CAAC,GAAGiG,OAAO,CAAChJ,MAAnB,EAA2B+C,CAAC,EAA5B,EAAgC;AAC9B;AACA;AACA,UAAIiG,OAAO,CAACjG,CAAD,CAAP,CAAW+H,OAAX,CAAmB,MAAnB,MAA+B,CAA/B,IAAoC/H,CAAC,GAAG,CAAJ,GAAQiG,OAAO,CAAChJ,MAApD,IAA8DgJ,OAAO,CAACjG,CAAC,GAAG,CAAL,CAAP,CAAe+H,OAAf,CAAuB,MAAvB,MAAmC,CAAjG,IAAsG9B,OAAO,CAACjG,CAAC,GAAG,CAAL,CAAP,CAAe+H,OAAf,CAAuB,IAAvB,MAAiC,CAA3I,EAA8I;AAC5I;AACD;;AAED,UAAIC,SAAS,GAAG/B,OAAO,CAACjG,CAAD,CAAP,CAAW/C,MAAX,IAAqB,CAArB,IAA0B+C,CAAC,IAAIiG,OAAO,CAAChJ,MAAR,GAAiB,CAAhD,GAAoD,GAApD,GAA0DgJ,OAAO,CAACjG,CAAD,CAAP,CAAW,CAAX,CAA1E;;AAEA,UAAIgI,SAAS,KAAK,GAAd,IAAqBA,SAAS,KAAK,GAAnC,IAA0CA,SAAS,KAAK,GAAxD,IAA+DA,SAAS,KAAK,IAAjF,EAAuF;AACrFV,QAAAA,IAAI,CAACK,KAAL,CAAWpI,IAAX,CAAgB0G,OAAO,CAACjG,CAAD,CAAvB;AACAsH,QAAAA,IAAI,CAACM,cAAL,CAAoBrI,IAApB,CAAyB2G,UAAU,CAAClG,CAAD,CAAV,IAAiB,IAA1C;;AAEA,YAAIgI,SAAS,KAAK,GAAlB,EAAuB;AACrBH,UAAAA,QAAQ;AACT,SAFD,MAEO,IAAIG,SAAS,KAAK,GAAlB,EAAuB;AAC5BF,UAAAA,WAAW;AACZ,SAFM,MAEA,IAAIE,SAAS,KAAK,GAAlB,EAAuB;AAC5BH,UAAAA,QAAQ;AACRC,UAAAA,WAAW;AACZ;AACF,OAZD,MAYO;AACL;AACD;AACF,KAlDkB,CAkDjB;;;AAGF,QAAI,CAACD,QAAD,IAAaP,IAAI,CAACI,QAAL,KAAkB,CAAnC,EAAsC;AACpCJ,MAAAA,IAAI,CAACI,QAAL,GAAgB,CAAhB;AACD;;AAED,QAAI,CAACI,WAAD,IAAgBR,IAAI,CAACE,QAAL,KAAkB,CAAtC,EAAyC;AACvCF,MAAAA,IAAI,CAACE,QAAL,GAAgB,CAAhB;AACD,KA3DkB,CA2DjB;;;AAGF,QAAIzK,OAAO,CAAC6J,MAAZ,EAAoB;AAClB,UAAIiB,QAAQ,KAAKP,IAAI,CAACI,QAAtB,EAAgC;AAC9B,cAAM,IAAIb,KAAJ,CAAU,sDAAsDM,gBAAgB,GAAG,CAAzE,CAAV,CAAN;AACD;;AAED,UAAIW,WAAW,KAAKR,IAAI,CAACE,QAAzB,EAAmC;AACjC,cAAM,IAAIX,KAAJ,CAAU,wDAAwDM,gBAAgB,GAAG,CAA3E,CAAV,CAAN;AACD;AACF;;AAED,WAAOG,IAAP;AACD;;AAED,SAAOtH,CAAC,GAAGiG,OAAO,CAAChJ,MAAnB,EAA2B;AACzBoJ,IAAAA,UAAU;AACX;;AAED,SAAOD,IAAP;AACD,C,CAED;AACA;AACA;;;AACA,SAAS6B,gBAAT,CAA2BC,KAA3B,EAAkCC,OAAlC,EAA2CC,OAA3C,EAAoD;AAClD,MAAIC,WAAW,GAAG,IAAlB;AAAA,MACIC,iBAAiB,GAAG,KADxB;AAAA,MAEIC,gBAAgB,GAAG,KAFvB;AAAA,MAGIC,WAAW,GAAG,CAHlB;AAIA,SAAO,SAAS3F,QAAT,GAAoB;AACzB,QAAIwF,WAAW,IAAI,CAACE,gBAApB,EAAsC;AACpC,UAAID,iBAAJ,EAAuB;AACrBE,QAAAA,WAAW;AACZ,OAFD,MAEO;AACLH,QAAAA,WAAW,GAAG,KAAd;AACD,OALmC,CAKlC;AACF;;;AAGA,UAAIH,KAAK,GAAGM,WAAR,IAAuBJ,OAA3B,EAAoC;AAClC,eAAOI,WAAP;AACD;;AAEDD,MAAAA,gBAAgB,GAAG,IAAnB;AACD;;AAED,QAAI,CAACD,iBAAL,EAAwB;AACtB,UAAI,CAACC,gBAAL,EAAuB;AACrBF,QAAAA,WAAW,GAAG,IAAd;AACD,OAHqB,CAGpB;AACF;;;AAGA,UAAIF,OAAO,IAAID,KAAK,GAAGM,WAAvB,EAAoC;AAClC,eAAO,CAACA,WAAW,EAAnB;AACD;;AAEDF,MAAAA,iBAAiB,GAAG,IAApB;AACA,aAAOzF,QAAQ,EAAf;AACD,KA9BwB,CA8BvB;AACF;;AAED,GAjCD;AAkCD;;AAED,SAAS4F,UAAT,CAAoBC,MAApB,EAA4B1C,OAA5B,EAAqC;AACnC,MAAIjJ,OAAO,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAlF;;AAEA,MAAI,OAAOgJ,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAGD,UAAU,CAACC,OAAD,CAApB;AACD;;AAED,MAAI3C,KAAK,CAACC,OAAN,CAAc0C,OAAd,CAAJ,EAA4B;AAC1B,QAAIA,OAAO,CAAC/I,MAAR,GAAiB,CAArB,EAAwB;AACtB,YAAM,IAAI4J,KAAJ,CAAU,4CAAV,CAAN;AACD;;AAEDb,IAAAA,OAAO,GAAGA,OAAO,CAAC,CAAD,CAAjB;AACD,GAbkC,CAajC;;;AAGF,MAAI2B,KAAK,GAAGe,MAAM,CAACzI,KAAP,CAAa,qBAAb,CAAZ;AAAA,MACIiG,UAAU,GAAGwC,MAAM,CAACvC,KAAP,CAAa,sBAAb,KAAwC,EADzD;AAAA,MAEIM,KAAK,GAAGT,OAAO,CAACS,KAFpB;AAAA,MAGIkC,WAAW,GAAG5L,OAAO,CAAC4L,WAAR,IAAuB,UAAUC,UAAV,EAAsB3G,IAAtB,EAA4B+F,SAA5B,EAAuCa,YAAvC,EAAqD;AAC5F,WAAO5G,IAAI,KAAK4G,YAAhB;AACD,GALD;AAAA,MAMIC,UAAU,GAAG,CANjB;AAAA,MAOIC,UAAU,GAAGhM,OAAO,CAACgM,UAAR,IAAsB,CAPvC;AAAA,MAQIZ,OAAO,GAAG,CARd;AAAA,MASIa,MAAM,GAAG,CATb;AAAA,MAUIC,WAVJ;AAAA,MAWIC,QAXJ;AAYA;AACF;AACA;;;AAGE,WAASC,QAAT,CAAkB7B,IAAlB,EAAwB8B,KAAxB,EAA+B;AAC7B,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,IAAI,CAACK,KAAL,CAAW1K,MAA/B,EAAuCoM,CAAC,EAAxC,EAA4C;AAC1C,UAAIpH,IAAI,GAAGqF,IAAI,CAACK,KAAL,CAAW0B,CAAX,CAAX;AAAA,UACIrB,SAAS,GAAG/F,IAAI,CAAChF,MAAL,GAAc,CAAd,GAAkBgF,IAAI,CAAC,CAAD,CAAtB,GAA4B,GAD5C;AAAA,UAEIqH,OAAO,GAAGrH,IAAI,CAAChF,MAAL,GAAc,CAAd,GAAkBgF,IAAI,CAACiF,MAAL,CAAY,CAAZ,CAAlB,GAAmCjF,IAFjD;;AAIA,UAAI+F,SAAS,KAAK,GAAd,IAAqBA,SAAS,KAAK,GAAvC,EAA4C;AAC1C;AACA,YAAI,CAACW,WAAW,CAACS,KAAK,GAAG,CAAT,EAAYzB,KAAK,CAACyB,KAAD,CAAjB,EAA0BpB,SAA1B,EAAqCsB,OAArC,CAAhB,EAA+D;AAC7DR,UAAAA,UAAU;;AAEV,cAAIA,UAAU,GAAGC,UAAjB,EAA6B;AAC3B,mBAAO,KAAP;AACD;AACF;;AAEDK,QAAAA,KAAK;AACN;AACF;;AAED,WAAO,IAAP;AACD,GAtDkC,CAsDjC;;;AAGF,OAAK,IAAIpJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGyG,KAAK,CAACxJ,MAA1B,EAAkC+C,CAAC,EAAnC,EAAuC;AACrC,QAAIsH,IAAI,GAAGb,KAAK,CAACzG,CAAD,CAAhB;AAAA,QACIoI,OAAO,GAAGT,KAAK,CAAC1K,MAAN,GAAeqK,IAAI,CAACE,QADlC;AAAA,QAEIgB,WAAW,GAAG,CAFlB;AAAA,QAGIY,KAAK,GAAGJ,MAAM,GAAG1B,IAAI,CAACC,QAAd,GAAyB,CAHrC;AAIA,QAAI1E,QAAQ,GAAGoF,gBAAgB,CAACmB,KAAD,EAAQjB,OAAR,EAAiBC,OAAjB,CAA/B;;AAEA,WAAOI,WAAW,KAAKtL,SAAvB,EAAkCsL,WAAW,GAAG3F,QAAQ,EAAxD,EAA4D;AAC1D,UAAIsG,QAAQ,CAAC7B,IAAD,EAAO8B,KAAK,GAAGZ,WAAf,CAAZ,EAAyC;AACvClB,QAAAA,IAAI,CAAC0B,MAAL,GAAcA,MAAM,IAAIR,WAAxB;AACA;AACD;AACF;;AAED,QAAIA,WAAW,KAAKtL,SAApB,EAA+B;AAC7B,aAAO,KAAP;AACD,KAhBoC,CAgBnC;AACF;;;AAGAiL,IAAAA,OAAO,GAAGb,IAAI,CAAC0B,MAAL,GAAc1B,IAAI,CAACC,QAAnB,GAA8BD,IAAI,CAACE,QAA7C;AACD,GA9EkC,CA8EjC;;;AAGF,MAAI+B,UAAU,GAAG,CAAjB;;AAEA,OAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG/C,KAAK,CAACxJ,MAA5B,EAAoCuM,EAAE,EAAtC,EAA0C;AACxC,QAAIC,KAAK,GAAGhD,KAAK,CAAC+C,EAAD,CAAjB;AAAA,QACIE,MAAM,GAAGD,KAAK,CAAClC,QAAN,GAAiBkC,KAAK,CAACT,MAAvB,GAAgCO,UAAhC,GAA6C,CAD1D;;AAGAA,IAAAA,UAAU,IAAIE,KAAK,CAAC/B,QAAN,GAAiB+B,KAAK,CAACjC,QAArC;;AAEA,SAAK,IAAI6B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGI,KAAK,CAAC9B,KAAN,CAAY1K,MAAhC,EAAwCoM,CAAC,EAAzC,EAA6C;AAC3C,UAAIpH,IAAI,GAAGwH,KAAK,CAAC9B,KAAN,CAAY0B,CAAZ,CAAX;AAAA,UACIrB,SAAS,GAAG/F,IAAI,CAAChF,MAAL,GAAc,CAAd,GAAkBgF,IAAI,CAAC,CAAD,CAAtB,GAA4B,GAD5C;AAAA,UAEIqH,OAAO,GAAGrH,IAAI,CAAChF,MAAL,GAAc,CAAd,GAAkBgF,IAAI,CAACiF,MAAL,CAAY,CAAZ,CAAlB,GAAmCjF,IAFjD;AAAA,UAGI0H,SAAS,GAAGF,KAAK,CAAC7B,cAAN,CAAqByB,CAArB,CAHhB;;AAKA,UAAIrB,SAAS,KAAK,GAAlB,EAAuB;AACrB0B,QAAAA,MAAM;AACP,OAFD,MAEO,IAAI1B,SAAS,KAAK,GAAlB,EAAuB;AAC5BL,QAAAA,KAAK,CAAChG,MAAN,CAAa+H,MAAb,EAAqB,CAArB;AACAxD,QAAAA,UAAU,CAACvE,MAAX,CAAkB+H,MAAlB,EAA0B,CAA1B;AACA;AACD,OAJM,MAIA,IAAI1B,SAAS,KAAK,GAAlB,EAAuB;AAC5BL,QAAAA,KAAK,CAAChG,MAAN,CAAa+H,MAAb,EAAqB,CAArB,EAAwBJ,OAAxB;AACApD,QAAAA,UAAU,CAACvE,MAAX,CAAkB+H,MAAlB,EAA0B,CAA1B,EAA6BC,SAA7B;AACAD,QAAAA,MAAM;AACP,OAJM,MAIA,IAAI1B,SAAS,KAAK,IAAlB,EAAwB;AAC7B,YAAI4B,iBAAiB,GAAGH,KAAK,CAAC9B,KAAN,CAAY0B,CAAC,GAAG,CAAhB,IAAqBI,KAAK,CAAC9B,KAAN,CAAY0B,CAAC,GAAG,CAAhB,EAAmB,CAAnB,CAArB,GAA6C,IAArE;;AAEA,YAAIO,iBAAiB,KAAK,GAA1B,EAA+B;AAC7BX,UAAAA,WAAW,GAAG,IAAd;AACD,SAFD,MAEO,IAAIW,iBAAiB,KAAK,GAA1B,EAA+B;AACpCV,UAAAA,QAAQ,GAAG,IAAX;AACD;AACF;AACF;AACF,GAnHkC,CAmHjC;;;AAGF,MAAID,WAAJ,EAAiB;AACf,WAAO,CAACtB,KAAK,CAACA,KAAK,CAAC1K,MAAN,GAAe,CAAhB,CAAb,EAAiC;AAC/B0K,MAAAA,KAAK,CAAChH,GAAN;AACAuF,MAAAA,UAAU,CAACvF,GAAX;AACD;AACF,GALD,MAKO,IAAIuI,QAAJ,EAAc;AACnBvB,IAAAA,KAAK,CAACpI,IAAN,CAAW,EAAX;AACA2G,IAAAA,UAAU,CAAC3G,IAAX,CAAgB,IAAhB;AACD;;AAED,OAAK,IAAIsK,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGlC,KAAK,CAAC1K,MAAN,GAAe,CAArC,EAAwC4M,EAAE,EAA1C,EAA8C;AAC5ClC,IAAAA,KAAK,CAACkC,EAAD,CAAL,GAAYlC,KAAK,CAACkC,EAAD,CAAL,GAAY3D,UAAU,CAAC2D,EAAD,CAAlC;AACD;;AAED,SAAOlC,KAAK,CAACvJ,IAAN,CAAW,EAAX,CAAP;AACD,C,CAAC;;;AAEF,SAAS0L,YAAT,CAAsB9D,OAAtB,EAA+BjJ,OAA/B,EAAwC;AACtC,MAAI,OAAOiJ,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAGD,UAAU,CAACC,OAAD,CAApB;AACD;;AAED,MAAI+D,YAAY,GAAG,CAAnB;;AAEA,WAASC,YAAT,GAAwB;AACtB,QAAI1D,KAAK,GAAGN,OAAO,CAAC+D,YAAY,EAAb,CAAnB;;AAEA,QAAI,CAACzD,KAAL,EAAY;AACV,aAAOvJ,OAAO,CAACkN,QAAR,EAAP;AACD;;AAEDlN,IAAAA,OAAO,CAACmN,QAAR,CAAiB5D,KAAjB,EAAwB,UAAU6D,GAAV,EAAenD,IAAf,EAAqB;AAC3C,UAAImD,GAAJ,EAAS;AACP,eAAOpN,OAAO,CAACkN,QAAR,CAAiBE,GAAjB,CAAP;AACD;;AAED,UAAIC,cAAc,GAAG3B,UAAU,CAACzB,IAAD,EAAOV,KAAP,EAAcvJ,OAAd,CAA/B;AACAA,MAAAA,OAAO,CAACsN,OAAR,CAAgB/D,KAAhB,EAAuB8D,cAAvB,EAAuC,UAAUD,GAAV,EAAe;AACpD,YAAIA,GAAJ,EAAS;AACP,iBAAOpN,OAAO,CAACkN,QAAR,CAAiBE,GAAjB,CAAP;AACD;;AAEDH,QAAAA,YAAY;AACb,OAND;AAOD,KAbD;AAcD;;AAEDA,EAAAA,YAAY;AACb;;AAED,SAASM,eAAT,CAAyBC,WAAzB,EAAsCC,WAAtC,EAAmDzJ,MAAnD,EAA2DC,MAA3D,EAAmEyJ,SAAnE,EAA8EC,SAA9E,EAAyF3N,OAAzF,EAAkG;AAChG,MAAI,CAACA,OAAL,EAAc;AACZA,IAAAA,OAAO,GAAG,EAAV;AACD;;AAED,MAAI,OAAOA,OAAO,CAAC4N,OAAf,KAA2B,WAA/B,EAA4C;AAC1C5N,IAAAA,OAAO,CAAC4N,OAAR,GAAkB,CAAlB;AACD;;AAED,MAAI/N,IAAI,GAAGwF,SAAS,CAACrB,MAAD,EAASC,MAAT,EAAiBjE,OAAjB,CAApB;AACAH,EAAAA,IAAI,CAAC2C,IAAL,CAAU;AACRjC,IAAAA,KAAK,EAAE,EADC;AAERqK,IAAAA,KAAK,EAAE;AAFC,GAAV,EAVgG,CAa5F;;AAEJ,WAASiD,YAAT,CAAsBjD,KAAtB,EAA6B;AAC3B,WAAOA,KAAK,CAACpH,GAAN,CAAU,UAAUsK,KAAV,EAAiB;AAChC,aAAO,MAAMA,KAAb;AACD,KAFM,CAAP;AAGD;;AAED,MAAIpE,KAAK,GAAG,EAAZ;AACA,MAAIqE,aAAa,GAAG,CAApB;AAAA,MACIC,aAAa,GAAG,CADpB;AAAA,MAEIC,QAAQ,GAAG,EAFf;AAAA,MAGIC,OAAO,GAAG,CAHd;AAAA,MAIIC,OAAO,GAAG,CAJd;;AAMA,MAAIC,KAAK,GAAG,SAASA,KAAT,CAAenL,CAAf,EAAkB;AAC5B,QAAIoL,OAAO,GAAGxO,IAAI,CAACoD,CAAD,CAAlB;AAAA,QACI2H,KAAK,GAAGyD,OAAO,CAACzD,KAAR,IAAiByD,OAAO,CAAC9N,KAAR,CAAcwH,OAAd,CAAsB,KAAtB,EAA6B,EAA7B,EAAiC7E,KAAjC,CAAuC,IAAvC,CAD7B;AAEAmL,IAAAA,OAAO,CAACzD,KAAR,GAAgBA,KAAhB;;AAEA,QAAIyD,OAAO,CAAChM,KAAR,IAAiBgM,OAAO,CAAC/L,OAA7B,EAAsC;AACpC,UAAIgM,SAAJ,CADoC,CAGpC;;;AACA,UAAI,CAACP,aAAL,EAAoB;AAClB,YAAIQ,IAAI,GAAG1O,IAAI,CAACoD,CAAC,GAAG,CAAL,CAAf;AACA8K,QAAAA,aAAa,GAAGG,OAAhB;AACAF,QAAAA,aAAa,GAAGG,OAAhB;;AAEA,YAAII,IAAJ,EAAU;AACRN,UAAAA,QAAQ,GAAGjO,OAAO,CAAC4N,OAAR,GAAkB,CAAlB,GAAsBC,YAAY,CAACU,IAAI,CAAC3D,KAAL,CAAWrH,KAAX,CAAiB,CAACvD,OAAO,CAAC4N,OAA1B,CAAD,CAAlC,GAAyE,EAApF;AACAG,UAAAA,aAAa,IAAIE,QAAQ,CAAC/N,MAA1B;AACA8N,UAAAA,aAAa,IAAIC,QAAQ,CAAC/N,MAA1B;AACD;AACF,OAdmC,CAclC;;;AAGF,OAACoO,SAAS,GAAGL,QAAb,EAAuBzL,IAAvB,CAA4BgM,KAA5B,CAAkCF,SAAlC,EAA6CtI,kBAAkB,CAAC4E,KAAK,CAACpH,GAAN,CAAU,UAAUsK,KAAV,EAAiB;AACzF,eAAO,CAACO,OAAO,CAAChM,KAAR,GAAgB,GAAhB,GAAsB,GAAvB,IAA8ByL,KAArC;AACD,OAF+D,CAAD,CAA/D,EAjBoC,CAmB9B;;;AAGN,UAAIO,OAAO,CAAChM,KAAZ,EAAmB;AACjB8L,QAAAA,OAAO,IAAIvD,KAAK,CAAC1K,MAAjB;AACD,OAFD,MAEO;AACLgO,QAAAA,OAAO,IAAItD,KAAK,CAAC1K,MAAjB;AACD;AACF,KA3BD,MA2BO;AACL;AACA,UAAI6N,aAAJ,EAAmB;AACjB;AACA,YAAInD,KAAK,CAAC1K,MAAN,IAAgBF,OAAO,CAAC4N,OAAR,GAAkB,CAAlC,IAAuC3K,CAAC,GAAGpD,IAAI,CAACK,MAAL,GAAc,CAA7D,EAAgE;AAC9D,cAAIuO,UAAJ,CAD8D,CAG9D;;;AACA,WAACA,UAAU,GAAGR,QAAd,EAAwBzL,IAAxB,CAA6BgM,KAA7B,CAAmCC,UAAnC,EAA+CzI,kBAAkB,CAAC6H,YAAY,CAACjD,KAAD,CAAb,CAAjE;AACD,SALD,MAKO;AACL,cAAI8D,UAAJ,CADK,CAGL;;;AACA,cAAIC,WAAW,GAAGC,IAAI,CAACC,GAAL,CAASjE,KAAK,CAAC1K,MAAf,EAAuBF,OAAO,CAAC4N,OAA/B,CAAlB;;AAEA,WAACc,UAAU,GAAGT,QAAd,EAAwBzL,IAAxB,CAA6BgM,KAA7B,CAAmCE,UAAnC,EAA+C1I,kBAAkB,CAAC6H,YAAY,CAACjD,KAAK,CAACrH,KAAN,CAAY,CAAZ,EAAeoL,WAAf,CAAD,CAAb,CAAjE;;AAEA,cAAIpE,IAAI,GAAG;AACTC,YAAAA,QAAQ,EAAEuD,aADD;AAETtD,YAAAA,QAAQ,EAAEyD,OAAO,GAAGH,aAAV,GAA0BY,WAF3B;AAGTjE,YAAAA,QAAQ,EAAEsD,aAHD;AAITrD,YAAAA,QAAQ,EAAEwD,OAAO,GAAGH,aAAV,GAA0BW,WAJ3B;AAKT/D,YAAAA,KAAK,EAAEqD;AALE,WAAX;;AAQA,cAAIhL,CAAC,IAAIpD,IAAI,CAACK,MAAL,GAAc,CAAnB,IAAwB0K,KAAK,CAAC1K,MAAN,IAAgBF,OAAO,CAAC4N,OAApD,EAA6D;AAC3D;AACA,gBAAIkB,aAAa,GAAG,MAAMpK,IAAN,CAAWV,MAAX,CAApB;AACA,gBAAI+K,aAAa,GAAG,MAAMrK,IAAN,CAAWT,MAAX,CAApB;AACA,gBAAI+K,cAAc,GAAGpE,KAAK,CAAC1K,MAAN,IAAgB,CAAhB,IAAqB+N,QAAQ,CAAC/N,MAAT,GAAkBqK,IAAI,CAACE,QAAjE;;AAEA,gBAAI,CAACqE,aAAD,IAAkBE,cAAlB,IAAoChL,MAAM,CAAC9D,MAAP,GAAgB,CAAxD,EAA2D;AACzD;AACA;AACA+N,cAAAA,QAAQ,CAACrJ,MAAT,CAAgB2F,IAAI,CAACE,QAArB,EAA+B,CAA/B,EAAkC,8BAAlC;AACD;;AAED,gBAAI,CAACqE,aAAD,IAAkB,CAACE,cAAnB,IAAqC,CAACD,aAA1C,EAAyD;AACvDd,cAAAA,QAAQ,CAACzL,IAAT,CAAc,8BAAd;AACD;AACF;;AAEDkH,UAAAA,KAAK,CAAClH,IAAN,CAAW+H,IAAX;AACAwD,UAAAA,aAAa,GAAG,CAAhB;AACAC,UAAAA,aAAa,GAAG,CAAhB;AACAC,UAAAA,QAAQ,GAAG,EAAX;AACD;AACF;;AAEDC,MAAAA,OAAO,IAAItD,KAAK,CAAC1K,MAAjB;AACAiO,MAAAA,OAAO,IAAIvD,KAAK,CAAC1K,MAAjB;AACD;AACF,GApFD;;AAsFA,OAAK,IAAI+C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpD,IAAI,CAACK,MAAzB,EAAiC+C,CAAC,EAAlC,EAAsC;AACpCmL,IAAAA,KAAK,CAACnL,CAAD,CAAL;AACD;;AAED,SAAO;AACLuK,IAAAA,WAAW,EAAEA,WADR;AAELC,IAAAA,WAAW,EAAEA,WAFR;AAGLC,IAAAA,SAAS,EAAEA,SAHN;AAILC,IAAAA,SAAS,EAAEA,SAJN;AAKLjE,IAAAA,KAAK,EAAEA;AALF,GAAP;AAOD;;AACD,SAASuF,WAAT,CAAqBpP,IAArB,EAA2B;AACzB,MAAIuC,GAAG,GAAG,EAAV;;AAEA,MAAIvC,IAAI,CAAC2N,WAAL,IAAoB3N,IAAI,CAAC4N,WAA7B,EAA0C;AACxCrL,IAAAA,GAAG,CAACI,IAAJ,CAAS,YAAY3C,IAAI,CAAC2N,WAA1B;AACD;;AAEDpL,EAAAA,GAAG,CAACI,IAAJ,CAAS,qEAAT;AACAJ,EAAAA,GAAG,CAACI,IAAJ,CAAS,SAAS3C,IAAI,CAAC2N,WAAd,IAA6B,OAAO3N,IAAI,CAAC6N,SAAZ,KAA0B,WAA1B,GAAwC,EAAxC,GAA6C,OAAO7N,IAAI,CAAC6N,SAAtF,CAAT;AACAtL,EAAAA,GAAG,CAACI,IAAJ,CAAS,SAAS3C,IAAI,CAAC4N,WAAd,IAA6B,OAAO5N,IAAI,CAAC8N,SAAZ,KAA0B,WAA1B,GAAwC,EAAxC,GAA6C,OAAO9N,IAAI,CAAC8N,SAAtF,CAAT;;AAEA,OAAK,IAAI1K,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpD,IAAI,CAAC6J,KAAL,CAAWxJ,MAA/B,EAAuC+C,CAAC,EAAxC,EAA4C;AAC1C,QAAIsH,IAAI,GAAG1K,IAAI,CAAC6J,KAAL,CAAWzG,CAAX,CAAX,CAD0C,CAChB;AAC1B;AACA;;AAEA,QAAIsH,IAAI,CAACE,QAAL,KAAkB,CAAtB,EAAyB;AACvBF,MAAAA,IAAI,CAACC,QAAL,IAAiB,CAAjB;AACD;;AAED,QAAID,IAAI,CAACI,QAAL,KAAkB,CAAtB,EAAyB;AACvBJ,MAAAA,IAAI,CAACG,QAAL,IAAiB,CAAjB;AACD;;AAEDtI,IAAAA,GAAG,CAACI,IAAJ,CAAS,SAAS+H,IAAI,CAACC,QAAd,GAAyB,GAAzB,GAA+BD,IAAI,CAACE,QAApC,GAA+C,IAA/C,GAAsDF,IAAI,CAACG,QAA3D,GAAsE,GAAtE,GAA4EH,IAAI,CAACI,QAAjF,GAA4F,KAArG;AACAvI,IAAAA,GAAG,CAACI,IAAJ,CAASgM,KAAT,CAAepM,GAAf,EAAoBmI,IAAI,CAACK,KAAzB;AACD;;AAED,SAAOxI,GAAG,CAACf,IAAJ,CAAS,IAAT,IAAiB,IAAxB;AACD;;AACD,SAAS6N,mBAAT,CAA6B1B,WAA7B,EAA0CC,WAA1C,EAAuDzJ,MAAvD,EAA+DC,MAA/D,EAAuEyJ,SAAvE,EAAkFC,SAAlF,EAA6F3N,OAA7F,EAAsG;AACpG,SAAOiP,WAAW,CAAC1B,eAAe,CAACC,WAAD,EAAcC,WAAd,EAA2BzJ,MAA3B,EAAmCC,MAAnC,EAA2CyJ,SAA3C,EAAsDC,SAAtD,EAAiE3N,OAAjE,CAAhB,CAAlB;AACD;;AACD,SAASmP,WAAT,CAAqBjF,QAArB,EAA+BlG,MAA/B,EAAuCC,MAAvC,EAA+CyJ,SAA/C,EAA0DC,SAA1D,EAAqE3N,OAArE,EAA8E;AAC5E,SAAOkP,mBAAmB,CAAChF,QAAD,EAAWA,QAAX,EAAqBlG,MAArB,EAA6BC,MAA7B,EAAqCyJ,SAArC,EAAgDC,SAAhD,EAA2D3N,OAA3D,CAA1B;AACD;;AAED,SAASoP,UAAT,CAAoBC,CAApB,EAAuBC,CAAvB,EAA0B;AACxB,MAAID,CAAC,CAACnP,MAAF,KAAaoP,CAAC,CAACpP,MAAnB,EAA2B;AACzB,WAAO,KAAP;AACD;;AAED,SAAOqP,eAAe,CAACF,CAAD,EAAIC,CAAJ,CAAtB;AACD;;AACD,SAASC,eAAT,CAAyBvM,KAAzB,EAAgCmI,KAAhC,EAAuC;AACrC,MAAIA,KAAK,CAACjL,MAAN,GAAe8C,KAAK,CAAC9C,MAAzB,EAAiC;AAC/B,WAAO,KAAP;AACD;;AAED,OAAK,IAAI+C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkI,KAAK,CAACjL,MAA1B,EAAkC+C,CAAC,EAAnC,EAAuC;AACrC,QAAIkI,KAAK,CAAClI,CAAD,CAAL,KAAaD,KAAK,CAACC,CAAD,CAAtB,EAA2B;AACzB,aAAO,KAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAED,SAASuM,aAAT,CAAuBjF,IAAvB,EAA6B;AAC3B,MAAIkF,oBAAoB,GAAGC,mBAAmB,CAACnF,IAAI,CAACK,KAAN,CAA9C;AAAA,MACIH,QAAQ,GAAGgF,oBAAoB,CAAChF,QADpC;AAAA,MAEIE,QAAQ,GAAG8E,oBAAoB,CAAC9E,QAFpC;;AAIA,MAAIF,QAAQ,KAAKtK,SAAjB,EAA4B;AAC1BoK,IAAAA,IAAI,CAACE,QAAL,GAAgBA,QAAhB;AACD,GAFD,MAEO;AACL,WAAOF,IAAI,CAACE,QAAZ;AACD;;AAED,MAAIE,QAAQ,KAAKxK,SAAjB,EAA4B;AAC1BoK,IAAAA,IAAI,CAACI,QAAL,GAAgBA,QAAhB;AACD,GAFD,MAEO;AACL,WAAOJ,IAAI,CAACI,QAAZ;AACD;AACF;;AACD,SAASgF,KAAT,CAAeC,IAAf,EAAqBC,MAArB,EAA6BC,IAA7B,EAAmC;AACjCF,EAAAA,IAAI,GAAGG,SAAS,CAACH,IAAD,EAAOE,IAAP,CAAhB;AACAD,EAAAA,MAAM,GAAGE,SAAS,CAACF,MAAD,EAASC,IAAT,CAAlB;AACA,MAAI1N,GAAG,GAAG,EAAV,CAHiC,CAGnB;AACd;AACA;;AAEA,MAAIwN,IAAI,CAACrG,KAAL,IAAcsG,MAAM,CAACtG,KAAzB,EAAgC;AAC9BnH,IAAAA,GAAG,CAACmH,KAAJ,GAAYqG,IAAI,CAACrG,KAAL,IAAcsG,MAAM,CAACtG,KAAjC;AACD;;AAED,MAAIqG,IAAI,CAACnC,WAAL,IAAoBoC,MAAM,CAACpC,WAA/B,EAA4C;AAC1C,QAAI,CAACuC,eAAe,CAACJ,IAAD,CAApB,EAA4B;AAC1B;AACAxN,MAAAA,GAAG,CAACoL,WAAJ,GAAkBqC,MAAM,CAACrC,WAAP,IAAsBoC,IAAI,CAACpC,WAA7C;AACApL,MAAAA,GAAG,CAACqL,WAAJ,GAAkBoC,MAAM,CAACpC,WAAP,IAAsBmC,IAAI,CAACnC,WAA7C;AACArL,MAAAA,GAAG,CAACsL,SAAJ,GAAgBmC,MAAM,CAACnC,SAAP,IAAoBkC,IAAI,CAAClC,SAAzC;AACAtL,MAAAA,GAAG,CAACuL,SAAJ,GAAgBkC,MAAM,CAAClC,SAAP,IAAoBiC,IAAI,CAACjC,SAAzC;AACD,KAND,MAMO,IAAI,CAACqC,eAAe,CAACH,MAAD,CAApB,EAA8B;AACnC;AACAzN,MAAAA,GAAG,CAACoL,WAAJ,GAAkBoC,IAAI,CAACpC,WAAvB;AACApL,MAAAA,GAAG,CAACqL,WAAJ,GAAkBmC,IAAI,CAACnC,WAAvB;AACArL,MAAAA,GAAG,CAACsL,SAAJ,GAAgBkC,IAAI,CAAClC,SAArB;AACAtL,MAAAA,GAAG,CAACuL,SAAJ,GAAgBiC,IAAI,CAACjC,SAArB;AACD,KANM,MAMA;AACL;AACAvL,MAAAA,GAAG,CAACoL,WAAJ,GAAkByC,WAAW,CAAC7N,GAAD,EAAMwN,IAAI,CAACpC,WAAX,EAAwBqC,MAAM,CAACrC,WAA/B,CAA7B;AACApL,MAAAA,GAAG,CAACqL,WAAJ,GAAkBwC,WAAW,CAAC7N,GAAD,EAAMwN,IAAI,CAACnC,WAAX,EAAwBoC,MAAM,CAACpC,WAA/B,CAA7B;AACArL,MAAAA,GAAG,CAACsL,SAAJ,GAAgBuC,WAAW,CAAC7N,GAAD,EAAMwN,IAAI,CAAClC,SAAX,EAAsBmC,MAAM,CAACnC,SAA7B,CAA3B;AACAtL,MAAAA,GAAG,CAACuL,SAAJ,GAAgBsC,WAAW,CAAC7N,GAAD,EAAMwN,IAAI,CAACjC,SAAX,EAAsBkC,MAAM,CAAClC,SAA7B,CAA3B;AACD;AACF;;AAEDvL,EAAAA,GAAG,CAACsH,KAAJ,GAAY,EAAZ;AACA,MAAIwG,SAAS,GAAG,CAAhB;AAAA,MACIC,WAAW,GAAG,CADlB;AAAA,MAEIC,UAAU,GAAG,CAFjB;AAAA,MAGIC,YAAY,GAAG,CAHnB;;AAKA,SAAOH,SAAS,GAAGN,IAAI,CAAClG,KAAL,CAAWxJ,MAAvB,IAAiCiQ,WAAW,GAAGN,MAAM,CAACnG,KAAP,CAAaxJ,MAAnE,EAA2E;AACzE,QAAIoQ,WAAW,GAAGV,IAAI,CAAClG,KAAL,CAAWwG,SAAX,KAAyB;AACzC1F,MAAAA,QAAQ,EAAE+F;AAD+B,KAA3C;AAAA,QAGIC,aAAa,GAAGX,MAAM,CAACnG,KAAP,CAAayG,WAAb,KAA6B;AAC/C3F,MAAAA,QAAQ,EAAE+F;AADqC,KAHjD;;AAOA,QAAIE,UAAU,CAACH,WAAD,EAAcE,aAAd,CAAd,EAA4C;AAC1C;AACApO,MAAAA,GAAG,CAACsH,KAAJ,CAAUlH,IAAV,CAAekO,SAAS,CAACJ,WAAD,EAAcF,UAAd,CAAxB;AACAF,MAAAA,SAAS;AACTG,MAAAA,YAAY,IAAIC,WAAW,CAAC3F,QAAZ,GAAuB2F,WAAW,CAAC7F,QAAnD;AACD,KALD,MAKO,IAAIgG,UAAU,CAACD,aAAD,EAAgBF,WAAhB,CAAd,EAA4C;AACjD;AACAlO,MAAAA,GAAG,CAACsH,KAAJ,CAAUlH,IAAV,CAAekO,SAAS,CAACF,aAAD,EAAgBH,YAAhB,CAAxB;AACAF,MAAAA,WAAW;AACXC,MAAAA,UAAU,IAAII,aAAa,CAAC7F,QAAd,GAAyB6F,aAAa,CAAC/F,QAArD;AACD,KALM,MAKA;AACL;AACA,UAAIkG,UAAU,GAAG;AACfnG,QAAAA,QAAQ,EAAEoE,IAAI,CAACC,GAAL,CAASyB,WAAW,CAAC9F,QAArB,EAA+BgG,aAAa,CAAChG,QAA7C,CADK;AAEfC,QAAAA,QAAQ,EAAE,CAFK;AAGfC,QAAAA,QAAQ,EAAEkE,IAAI,CAACC,GAAL,CAASyB,WAAW,CAAC5F,QAAZ,GAAuB0F,UAAhC,EAA4CI,aAAa,CAAChG,QAAd,GAAyB6F,YAArE,CAHK;AAIf1F,QAAAA,QAAQ,EAAE,CAJK;AAKfC,QAAAA,KAAK,EAAE;AALQ,OAAjB;AAOAgG,MAAAA,UAAU,CAACD,UAAD,EAAaL,WAAW,CAAC9F,QAAzB,EAAmC8F,WAAW,CAAC1F,KAA/C,EAAsD4F,aAAa,CAAChG,QAApE,EAA8EgG,aAAa,CAAC5F,KAA5F,CAAV;AACAuF,MAAAA,WAAW;AACXD,MAAAA,SAAS;AACT9N,MAAAA,GAAG,CAACsH,KAAJ,CAAUlH,IAAV,CAAemO,UAAf;AACD;AACF;;AAED,SAAOvO,GAAP;AACD;;AAED,SAAS2N,SAAT,CAAmBc,KAAnB,EAA0Bf,IAA1B,EAAgC;AAC9B,MAAI,OAAOe,KAAP,KAAiB,QAArB,EAA+B;AAC7B,QAAI,OAAOnM,IAAP,CAAYmM,KAAZ,KAAsB,WAAWnM,IAAX,CAAgBmM,KAAhB,CAA1B,EAAkD;AAChD,aAAO7H,UAAU,CAAC6H,KAAD,CAAV,CAAkB,CAAlB,CAAP;AACD;;AAED,QAAI,CAACf,IAAL,EAAW;AACT,YAAM,IAAIhG,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED,WAAOyD,eAAe,CAACpN,SAAD,EAAYA,SAAZ,EAAuB2P,IAAvB,EAA6Be,KAA7B,CAAtB;AACD;;AAED,SAAOA,KAAP;AACD;;AAED,SAASb,eAAT,CAAyBc,KAAzB,EAAgC;AAC9B,SAAOA,KAAK,CAACrD,WAAN,IAAqBqD,KAAK,CAACrD,WAAN,KAAsBqD,KAAK,CAACtD,WAAxD;AACD;;AAED,SAASyC,WAAT,CAAqB1G,KAArB,EAA4BqG,IAA5B,EAAkCC,MAAlC,EAA0C;AACxC,MAAID,IAAI,KAAKC,MAAb,EAAqB;AACnB,WAAOD,IAAP;AACD,GAFD,MAEO;AACLrG,IAAAA,KAAK,CAACwH,QAAN,GAAiB,IAAjB;AACA,WAAO;AACLnB,MAAAA,IAAI,EAAEA,IADD;AAELC,MAAAA,MAAM,EAAEA;AAFH,KAAP;AAID;AACF;;AAED,SAASY,UAAT,CAAoB/L,IAApB,EAA0BsM,KAA1B,EAAiC;AAC/B,SAAOtM,IAAI,CAAC8F,QAAL,GAAgBwG,KAAK,CAACxG,QAAtB,IAAkC9F,IAAI,CAAC8F,QAAL,GAAgB9F,IAAI,CAAC+F,QAArB,GAAgCuG,KAAK,CAACxG,QAA/E;AACD;;AAED,SAASkG,SAAT,CAAmBnG,IAAnB,EAAyB0B,MAAzB,EAAiC;AAC/B,SAAO;AACLzB,IAAAA,QAAQ,EAAED,IAAI,CAACC,QADV;AAELC,IAAAA,QAAQ,EAAEF,IAAI,CAACE,QAFV;AAGLC,IAAAA,QAAQ,EAAEH,IAAI,CAACG,QAAL,GAAgBuB,MAHrB;AAILtB,IAAAA,QAAQ,EAAEJ,IAAI,CAACI,QAJV;AAKLC,IAAAA,KAAK,EAAEL,IAAI,CAACK;AALP,GAAP;AAOD;;AAED,SAASgG,UAAT,CAAoBrG,IAApB,EAA0B6F,UAA1B,EAAsCa,SAAtC,EAAiDC,WAAjD,EAA8DC,UAA9D,EAA0E;AACxE;AACA;AACA,MAAIvB,IAAI,GAAG;AACT3D,IAAAA,MAAM,EAAEmE,UADC;AAETxF,IAAAA,KAAK,EAAEqG,SAFE;AAGT1H,IAAAA,KAAK,EAAE;AAHE,GAAX;AAAA,MAKI6H,KAAK,GAAG;AACVnF,IAAAA,MAAM,EAAEiF,WADE;AAEVtG,IAAAA,KAAK,EAAEuG,UAFG;AAGV5H,IAAAA,KAAK,EAAE;AAHG,GALZ,CAHwE,CAYrE;;AAEH8H,EAAAA,aAAa,CAAC9G,IAAD,EAAOqF,IAAP,EAAawB,KAAb,CAAb;AACAC,EAAAA,aAAa,CAAC9G,IAAD,EAAO6G,KAAP,EAAcxB,IAAd,CAAb,CAfwE,CAetC;;AAElC,SAAOA,IAAI,CAACrG,KAAL,GAAaqG,IAAI,CAAChF,KAAL,CAAW1K,MAAxB,IAAkCkR,KAAK,CAAC7H,KAAN,GAAc6H,KAAK,CAACxG,KAAN,CAAY1K,MAAnE,EAA2E;AACzE,QAAIoQ,WAAW,GAAGV,IAAI,CAAChF,KAAL,CAAWgF,IAAI,CAACrG,KAAhB,CAAlB;AAAA,QACI+H,YAAY,GAAGF,KAAK,CAACxG,KAAN,CAAYwG,KAAK,CAAC7H,KAAlB,CADnB;;AAGA,QAAI,CAAC+G,WAAW,CAAC,CAAD,CAAX,KAAmB,GAAnB,IAA0BA,WAAW,CAAC,CAAD,CAAX,KAAmB,GAA9C,MAAuDgB,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAApB,IAA2BA,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAAtG,CAAJ,EAAgH;AAC9G;AACAC,MAAAA,YAAY,CAAChH,IAAD,EAAOqF,IAAP,EAAawB,KAAb,CAAZ;AACD,KAHD,MAGO,IAAId,WAAW,CAAC,CAAD,CAAX,KAAmB,GAAnB,IAA0BgB,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAAlD,EAAuD;AAC5D,UAAIE,WAAJ,CAD4D,CAG5D;;;AACA,OAACA,WAAW,GAAGjH,IAAI,CAACK,KAApB,EAA2BpI,IAA3B,CAAgCgM,KAAhC,CAAsCgD,WAAtC,EAAmDxL,kBAAkB,CAACyL,aAAa,CAAC7B,IAAD,CAAd,CAArE;AACD,KALM,MAKA,IAAI0B,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAApB,IAA2BhB,WAAW,CAAC,CAAD,CAAX,KAAmB,GAAlD,EAAuD;AAC5D,UAAIoB,YAAJ,CAD4D,CAG5D;;;AACA,OAACA,YAAY,GAAGnH,IAAI,CAACK,KAArB,EAA4BpI,IAA5B,CAAiCgM,KAAjC,CAAuCkD,YAAvC,EAAqD1L,kBAAkB,CAACyL,aAAa,CAACL,KAAD,CAAd,CAAvE;AACD,KALM,MAKA,IAAId,WAAW,CAAC,CAAD,CAAX,KAAmB,GAAnB,IAA0BgB,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAAlD,EAAuD;AAC5D;AACAK,MAAAA,OAAO,CAACpH,IAAD,EAAOqF,IAAP,EAAawB,KAAb,CAAP;AACD,KAHM,MAGA,IAAIE,YAAY,CAAC,CAAD,CAAZ,KAAoB,GAApB,IAA2BhB,WAAW,CAAC,CAAD,CAAX,KAAmB,GAAlD,EAAuD;AAC5D;AACAqB,MAAAA,OAAO,CAACpH,IAAD,EAAO6G,KAAP,EAAcxB,IAAd,EAAoB,IAApB,CAAP;AACD,KAHM,MAGA,IAAIU,WAAW,KAAKgB,YAApB,EAAkC;AACvC;AACA/G,MAAAA,IAAI,CAACK,KAAL,CAAWpI,IAAX,CAAgB8N,WAAhB;AACAV,MAAAA,IAAI,CAACrG,KAAL;AACA6H,MAAAA,KAAK,CAAC7H,KAAN;AACD,KALM,MAKA;AACL;AACAwH,MAAAA,QAAQ,CAACxG,IAAD,EAAOkH,aAAa,CAAC7B,IAAD,CAApB,EAA4B6B,aAAa,CAACL,KAAD,CAAzC,CAAR;AACD;AACF,GAjDuE,CAiDtE;;;AAGFQ,EAAAA,cAAc,CAACrH,IAAD,EAAOqF,IAAP,CAAd;AACAgC,EAAAA,cAAc,CAACrH,IAAD,EAAO6G,KAAP,CAAd;AACA5B,EAAAA,aAAa,CAACjF,IAAD,CAAb;AACD;;AAED,SAASgH,YAAT,CAAsBhH,IAAtB,EAA4BqF,IAA5B,EAAkCwB,KAAlC,EAAyC;AACvC,MAAIS,SAAS,GAAGJ,aAAa,CAAC7B,IAAD,CAA7B;AAAA,MACIkC,YAAY,GAAGL,aAAa,CAACL,KAAD,CADhC;;AAGA,MAAIW,UAAU,CAACF,SAAD,CAAV,IAAyBE,UAAU,CAACD,YAAD,CAAvC,EAAuD;AACrD;AACA,QAAIvC,eAAe,CAACsC,SAAD,EAAYC,YAAZ,CAAf,IAA4CE,kBAAkB,CAACZ,KAAD,EAAQS,SAAR,EAAmBA,SAAS,CAAC3R,MAAV,GAAmB4R,YAAY,CAAC5R,MAAnD,CAAlE,EAA8H;AAC5H,UAAI+R,YAAJ;;AAEA,OAACA,YAAY,GAAG1H,IAAI,CAACK,KAArB,EAA4BpI,IAA5B,CAAiCgM,KAAjC,CAAuCyD,YAAvC,EAAqDjM,kBAAkB,CAAC6L,SAAD,CAAvE;;AAEA;AACD,KAND,MAMO,IAAItC,eAAe,CAACuC,YAAD,EAAeD,SAAf,CAAf,IAA4CG,kBAAkB,CAACpC,IAAD,EAAOkC,YAAP,EAAqBA,YAAY,CAAC5R,MAAb,GAAsB2R,SAAS,CAAC3R,MAArD,CAAlE,EAAgI;AACrI,UAAIgS,YAAJ;;AAEA,OAACA,YAAY,GAAG3H,IAAI,CAACK,KAArB,EAA4BpI,IAA5B,CAAiCgM,KAAjC,CAAuC0D,YAAvC,EAAqDlM,kBAAkB,CAAC8L,YAAD,CAAvE;;AAEA;AACD;AACF,GAfD,MAeO,IAAI1C,UAAU,CAACyC,SAAD,EAAYC,YAAZ,CAAd,EAAyC;AAC9C,QAAIK,YAAJ;;AAEA,KAACA,YAAY,GAAG5H,IAAI,CAACK,KAArB,EAA4BpI,IAA5B,CAAiCgM,KAAjC,CAAuC2D,YAAvC,EAAqDnM,kBAAkB,CAAC6L,SAAD,CAAvE;;AAEA;AACD;;AAEDd,EAAAA,QAAQ,CAACxG,IAAD,EAAOsH,SAAP,EAAkBC,YAAlB,CAAR;AACD;;AAED,SAASH,OAAT,CAAiBpH,IAAjB,EAAuBqF,IAAvB,EAA6BwB,KAA7B,EAAoCgB,IAApC,EAA0C;AACxC,MAAIP,SAAS,GAAGJ,aAAa,CAAC7B,IAAD,CAA7B;AAAA,MACIkC,YAAY,GAAGO,cAAc,CAACjB,KAAD,EAAQS,SAAR,CADjC;;AAGA,MAAIC,YAAY,CAACQ,MAAjB,EAAyB;AACvB,QAAIC,YAAJ;;AAEA,KAACA,YAAY,GAAGhI,IAAI,CAACK,KAArB,EAA4BpI,IAA5B,CAAiCgM,KAAjC,CAAuC+D,YAAvC,EAAqDvM,kBAAkB,CAAC8L,YAAY,CAACQ,MAAd,CAAvE;AACD,GAJD,MAIO;AACLvB,IAAAA,QAAQ,CAACxG,IAAD,EAAO6H,IAAI,GAAGN,YAAH,GAAkBD,SAA7B,EAAwCO,IAAI,GAAGP,SAAH,GAAeC,YAA3D,CAAR;AACD;AACF;;AAED,SAASf,QAAT,CAAkBxG,IAAlB,EAAwBqF,IAAxB,EAA8BwB,KAA9B,EAAqC;AACnC7G,EAAAA,IAAI,CAACwG,QAAL,GAAgB,IAAhB;AACAxG,EAAAA,IAAI,CAACK,KAAL,CAAWpI,IAAX,CAAgB;AACduO,IAAAA,QAAQ,EAAE,IADI;AAEdnB,IAAAA,IAAI,EAAEA,IAFQ;AAGdC,IAAAA,MAAM,EAAEuB;AAHM,GAAhB;AAKD;;AAED,SAASC,aAAT,CAAuB9G,IAAvB,EAA6BiI,MAA7B,EAAqCpB,KAArC,EAA4C;AAC1C,SAAOoB,MAAM,CAACvG,MAAP,GAAgBmF,KAAK,CAACnF,MAAtB,IAAgCuG,MAAM,CAACjJ,KAAP,GAAeiJ,MAAM,CAAC5H,KAAP,CAAa1K,MAAnE,EAA2E;AACzE,QAAIgF,IAAI,GAAGsN,MAAM,CAAC5H,KAAP,CAAa4H,MAAM,CAACjJ,KAAP,EAAb,CAAX;AACAgB,IAAAA,IAAI,CAACK,KAAL,CAAWpI,IAAX,CAAgB0C,IAAhB;AACAsN,IAAAA,MAAM,CAACvG,MAAP;AACD;AACF;;AAED,SAAS2F,cAAT,CAAwBrH,IAAxB,EAA8BiI,MAA9B,EAAsC;AACpC,SAAOA,MAAM,CAACjJ,KAAP,GAAeiJ,MAAM,CAAC5H,KAAP,CAAa1K,MAAnC,EAA2C;AACzC,QAAIgF,IAAI,GAAGsN,MAAM,CAAC5H,KAAP,CAAa4H,MAAM,CAACjJ,KAAP,EAAb,CAAX;AACAgB,IAAAA,IAAI,CAACK,KAAL,CAAWpI,IAAX,CAAgB0C,IAAhB;AACD;AACF;;AAED,SAASuM,aAAT,CAAuBgB,KAAvB,EAA8B;AAC5B,MAAIrQ,GAAG,GAAG,EAAV;AAAA,MACI6I,SAAS,GAAGwH,KAAK,CAAC7H,KAAN,CAAY6H,KAAK,CAAClJ,KAAlB,EAAyB,CAAzB,CADhB;;AAGA,SAAOkJ,KAAK,CAAClJ,KAAN,GAAckJ,KAAK,CAAC7H,KAAN,CAAY1K,MAAjC,EAAyC;AACvC,QAAIgF,IAAI,GAAGuN,KAAK,CAAC7H,KAAN,CAAY6H,KAAK,CAAClJ,KAAlB,CAAX,CADuC,CACF;;AAErC,QAAI0B,SAAS,KAAK,GAAd,IAAqB/F,IAAI,CAAC,CAAD,CAAJ,KAAY,GAArC,EAA0C;AACxC+F,MAAAA,SAAS,GAAG,GAAZ;AACD;;AAED,QAAIA,SAAS,KAAK/F,IAAI,CAAC,CAAD,CAAtB,EAA2B;AACzB9C,MAAAA,GAAG,CAACI,IAAJ,CAAS0C,IAAT;AACAuN,MAAAA,KAAK,CAAClJ,KAAN;AACD,KAHD,MAGO;AACL;AACD;AACF;;AAED,SAAOnH,GAAP;AACD;;AAED,SAASiQ,cAAT,CAAwBI,KAAxB,EAA+BC,YAA/B,EAA6C;AAC3C,MAAIC,OAAO,GAAG,EAAd;AAAA,MACIL,MAAM,GAAG,EADb;AAAA,MAEIM,UAAU,GAAG,CAFjB;AAAA,MAGIC,cAAc,GAAG,KAHrB;AAAA,MAIIC,UAAU,GAAG,KAJjB;;AAMA,SAAOF,UAAU,GAAGF,YAAY,CAACxS,MAA1B,IAAoCuS,KAAK,CAAClJ,KAAN,GAAckJ,KAAK,CAAC7H,KAAN,CAAY1K,MAArE,EAA6E;AAC3E,QAAI6S,MAAM,GAAGN,KAAK,CAAC7H,KAAN,CAAY6H,KAAK,CAAClJ,KAAlB,CAAb;AAAA,QACIH,KAAK,GAAGsJ,YAAY,CAACE,UAAD,CADxB,CAD2E,CAErC;;AAEtC,QAAIxJ,KAAK,CAAC,CAAD,CAAL,KAAa,GAAjB,EAAsB;AACpB;AACD;;AAEDyJ,IAAAA,cAAc,GAAGA,cAAc,IAAIE,MAAM,CAAC,CAAD,CAAN,KAAc,GAAjD;AACAT,IAAAA,MAAM,CAAC9P,IAAP,CAAY4G,KAAZ;AACAwJ,IAAAA,UAAU,GAViE,CAU7D;AACd;;AAEA,QAAIG,MAAM,CAAC,CAAD,CAAN,KAAc,GAAlB,EAAuB;AACrBD,MAAAA,UAAU,GAAG,IAAb;;AAEA,aAAOC,MAAM,CAAC,CAAD,CAAN,KAAc,GAArB,EAA0B;AACxBJ,QAAAA,OAAO,CAACnQ,IAAR,CAAauQ,MAAb;AACAA,QAAAA,MAAM,GAAGN,KAAK,CAAC7H,KAAN,CAAY,EAAE6H,KAAK,CAAClJ,KAApB,CAAT;AACD;AACF;;AAED,QAAIH,KAAK,CAACe,MAAN,CAAa,CAAb,MAAoB4I,MAAM,CAAC5I,MAAP,CAAc,CAAd,CAAxB,EAA0C;AACxCwI,MAAAA,OAAO,CAACnQ,IAAR,CAAauQ,MAAb;AACAN,MAAAA,KAAK,CAAClJ,KAAN;AACD,KAHD,MAGO;AACLuJ,MAAAA,UAAU,GAAG,IAAb;AACD;AACF;;AAED,MAAI,CAACJ,YAAY,CAACE,UAAD,CAAZ,IAA4B,EAA7B,EAAiC,CAAjC,MAAwC,GAAxC,IAA+CC,cAAnD,EAAmE;AACjEC,IAAAA,UAAU,GAAG,IAAb;AACD;;AAED,MAAIA,UAAJ,EAAgB;AACd,WAAOH,OAAP;AACD;;AAED,SAAOC,UAAU,GAAGF,YAAY,CAACxS,MAAjC,EAAyC;AACvCoS,IAAAA,MAAM,CAAC9P,IAAP,CAAYkQ,YAAY,CAACE,UAAU,EAAX,CAAxB;AACD;;AAED,SAAO;AACLN,IAAAA,MAAM,EAAEA,MADH;AAELK,IAAAA,OAAO,EAAEA;AAFJ,GAAP;AAID;;AAED,SAASZ,UAAT,CAAoBY,OAApB,EAA6B;AAC3B,SAAOA,OAAO,CAACK,MAAR,CAAe,UAAUzE,IAAV,EAAgBwE,MAAhB,EAAwB;AAC5C,WAAOxE,IAAI,IAAIwE,MAAM,CAAC,CAAD,CAAN,KAAc,GAA7B;AACD,GAFM,EAEJ,IAFI,CAAP;AAGD;;AAED,SAASf,kBAAT,CAA4BS,KAA5B,EAAmCQ,aAAnC,EAAkDC,KAAlD,EAAyD;AACvD,OAAK,IAAIjQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiQ,KAApB,EAA2BjQ,CAAC,EAA5B,EAAgC;AAC9B,QAAIkQ,aAAa,GAAGF,aAAa,CAACA,aAAa,CAAC/S,MAAd,GAAuBgT,KAAvB,GAA+BjQ,CAAhC,CAAb,CAAgDkH,MAAhD,CAAuD,CAAvD,CAApB;;AAEA,QAAIsI,KAAK,CAAC7H,KAAN,CAAY6H,KAAK,CAAClJ,KAAN,GAActG,CAA1B,MAAiC,MAAMkQ,aAA3C,EAA0D;AACxD,aAAO,KAAP;AACD;AACF;;AAEDV,EAAAA,KAAK,CAAClJ,KAAN,IAAe2J,KAAf;AACA,SAAO,IAAP;AACD;;AAED,SAASxD,mBAAT,CAA6B9E,KAA7B,EAAoC;AAClC,MAAIH,QAAQ,GAAG,CAAf;AACA,MAAIE,QAAQ,GAAG,CAAf;AACAC,EAAAA,KAAK,CAACwI,OAAN,CAAc,UAAUlO,IAAV,EAAgB;AAC5B,QAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5B,UAAImO,OAAO,GAAG3D,mBAAmB,CAACxK,IAAI,CAAC0K,IAAN,CAAjC;AACA,UAAI0D,UAAU,GAAG5D,mBAAmB,CAACxK,IAAI,CAAC2K,MAAN,CAApC;;AAEA,UAAIpF,QAAQ,KAAKtK,SAAjB,EAA4B;AAC1B,YAAIkT,OAAO,CAAC5I,QAAR,KAAqB6I,UAAU,CAAC7I,QAApC,EAA8C;AAC5CA,UAAAA,QAAQ,IAAI4I,OAAO,CAAC5I,QAApB;AACD,SAFD,MAEO;AACLA,UAAAA,QAAQ,GAAGtK,SAAX;AACD;AACF;;AAED,UAAIwK,QAAQ,KAAKxK,SAAjB,EAA4B;AAC1B,YAAIkT,OAAO,CAAC1I,QAAR,KAAqB2I,UAAU,CAAC3I,QAApC,EAA8C;AAC5CA,UAAAA,QAAQ,IAAI0I,OAAO,CAAC1I,QAApB;AACD,SAFD,MAEO;AACLA,UAAAA,QAAQ,GAAGxK,SAAX;AACD;AACF;AACF,KAnBD,MAmBO;AACL,UAAIwK,QAAQ,KAAKxK,SAAb,KAA2B+E,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,IAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA1D,CAAJ,EAAoE;AAClEyF,QAAAA,QAAQ;AACT;;AAED,UAAIF,QAAQ,KAAKtK,SAAb,KAA2B+E,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,IAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA1D,CAAJ,EAAoE;AAClEuF,QAAAA,QAAQ;AACT;AACF;AACF,GA7BD;AA8BA,SAAO;AACLA,IAAAA,QAAQ,EAAEA,QADL;AAELE,IAAAA,QAAQ,EAAEA;AAFL,GAAP;AAID,C,CAED;;;AACA,SAAS4I,mBAAT,CAA6BZ,OAA7B,EAAsC;AACpC,MAAIvQ,GAAG,GAAG,EAAV;AAAA,MACI2Q,MADJ;AAAA,MAEI9H,SAFJ;;AAIA,OAAK,IAAIhI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0P,OAAO,CAACzS,MAA5B,EAAoC+C,CAAC,EAArC,EAAyC;AACvC8P,IAAAA,MAAM,GAAGJ,OAAO,CAAC1P,CAAD,CAAhB;;AAEA,QAAI8P,MAAM,CAAC1Q,KAAX,EAAkB;AAChB4I,MAAAA,SAAS,GAAG,CAAZ;AACD,KAFD,MAEO,IAAI8H,MAAM,CAACzQ,OAAX,EAAoB;AACzB2I,MAAAA,SAAS,GAAG,CAAC,CAAb;AACD,KAFM,MAEA;AACLA,MAAAA,SAAS,GAAG,CAAZ;AACD;;AAED7I,IAAAA,GAAG,CAACI,IAAJ,CAAS,CAACyI,SAAD,EAAY8H,MAAM,CAACxS,KAAnB,CAAT;AACD;;AAED,SAAO6B,GAAP;AACD;;AAED,SAASoR,mBAAT,CAA6Bb,OAA7B,EAAsC;AACpC,MAAIvQ,GAAG,GAAG,EAAV;;AAEA,OAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0P,OAAO,CAACzS,MAA5B,EAAoC+C,CAAC,EAArC,EAAyC;AACvC,QAAI8P,MAAM,GAAGJ,OAAO,CAAC1P,CAAD,CAApB;;AAEA,QAAI8P,MAAM,CAAC1Q,KAAX,EAAkB;AAChBD,MAAAA,GAAG,CAACI,IAAJ,CAAS,OAAT;AACD,KAFD,MAEO,IAAIuQ,MAAM,CAACzQ,OAAX,EAAoB;AACzBF,MAAAA,GAAG,CAACI,IAAJ,CAAS,OAAT;AACD;;AAEDJ,IAAAA,GAAG,CAACI,IAAJ,CAASiR,UAAU,CAACV,MAAM,CAACxS,KAAR,CAAnB;;AAEA,QAAIwS,MAAM,CAAC1Q,KAAX,EAAkB;AAChBD,MAAAA,GAAG,CAACI,IAAJ,CAAS,QAAT;AACD,KAFD,MAEO,IAAIuQ,MAAM,CAACzQ,OAAX,EAAoB;AACzBF,MAAAA,GAAG,CAACI,IAAJ,CAAS,QAAT;AACD;AACF;;AAED,SAAOJ,GAAG,CAACf,IAAJ,CAAS,EAAT,CAAP;AACD;;AAED,SAASoS,UAAT,CAAoBC,CAApB,EAAuB;AACrB,MAAI5M,CAAC,GAAG4M,CAAR;AACA5M,EAAAA,CAAC,GAAGA,CAAC,CAACiB,OAAF,CAAU,IAAV,EAAgB,OAAhB,CAAJ;AACAjB,EAAAA,CAAC,GAAGA,CAAC,CAACiB,OAAF,CAAU,IAAV,EAAgB,MAAhB,CAAJ;AACAjB,EAAAA,CAAC,GAAGA,CAAC,CAACiB,OAAF,CAAU,IAAV,EAAgB,MAAhB,CAAJ;AACAjB,EAAAA,CAAC,GAAGA,CAAC,CAACiB,OAAF,CAAU,IAAV,EAAgB,QAAhB,CAAJ;AACA,SAAOjB,CAAP;AACD;;AAED,SAASnH,IAAT,EAAe+L,UAAf,EAA2BqB,YAA3B,EAAyCjF,YAAzC,EAAuDyL,mBAAvD,EAA4EC,mBAA5E,EAAiGrE,WAAjG,EAA8GD,mBAA9G,EAAmIrG,UAAnI,EAA+I9E,SAA/I,EAA0J2B,OAA1J,EAAmKsC,QAAnK,EAA6K3C,SAA7K,EAAwLG,aAAxL,EAAuMF,gBAAvM,EAAyNT,SAAzN,EAAoOC,kBAApO,EAAwP6K,KAAxP,EAA+P3G,UAA/P,EAA2QuE,eAA3Q","sourcesContent":["function Diff() {}\nDiff.prototype = {\n  diff: function diff(oldString, newString) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    this.options = options;\n    var self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n        oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = void 0;\n\n        var addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n        commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n\n    return ret;\n  },\n  castInput: function castInput(value) {\n    return value;\n  },\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n\n  var lastComponent = components[componentLen - 1];\n\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar characterDiff = new Diff();\nfunction diffChars(oldStr, newStr, options) {\n  return characterDiff.diff(oldStr, newStr, options);\n}\n\nfunction generateOptions(options, defaults) {\n  if (typeof options === 'function') {\n    defaults.callback = options;\n  } else if (options) {\n    for (var name in options) {\n      /* istanbul ignore else */\n      if (options.hasOwnProperty(name)) {\n        defaults[name] = options[name];\n      }\n    }\n  }\n\n  return defaults;\n}\n\n//\n// Ranges and exceptions:\n// Latin-1 Supplement, 0080–00FF\n//  - U+00D7  × Multiplication sign\n//  - U+00F7  ÷ Division sign\n// Latin Extended-A, 0100–017F\n// Latin Extended-B, 0180–024F\n// IPA Extensions, 0250–02AF\n// Spacing Modifier Letters, 02B0–02FF\n//  - U+02C7  ˇ &#711;  Caron\n//  - U+02D8  ˘ &#728;  Breve\n//  - U+02D9  ˙ &#729;  Dot Above\n//  - U+02DA  ˚ &#730;  Ring Above\n//  - U+02DB  ˛ &#731;  Ogonek\n//  - U+02DC  ˜ &#732;  Small Tilde\n//  - U+02DD  ˝ &#733;  Double Acute Accent\n// Latin Extended Additional, 1E00–1EFF\n\nvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\nvar reWhitespace = /\\S/;\nvar wordDiff = new Diff();\n\nwordDiff.equals = function (left, right) {\n  if (this.options.ignoreCase) {\n    left = left.toLowerCase();\n    right = right.toLowerCase();\n  }\n\n  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n};\n\nwordDiff.tokenize = function (value) {\n  // All whitespace symbols except newline group into one token, each newline - in separate token\n  var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n  for (var i = 0; i < tokens.length - 1; i++) {\n    // If we have an empty string in the next field and we have only word chars before and after, merge\n    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n      tokens[i] += tokens[i + 2];\n      tokens.splice(i + 1, 2);\n      i--;\n    }\n  }\n\n  return tokens;\n};\n\nfunction diffWords(oldStr, newStr, options) {\n  options = generateOptions(options, {\n    ignoreWhitespace: true\n  });\n  return wordDiff.diff(oldStr, newStr, options);\n}\nfunction diffWordsWithSpace(oldStr, newStr, options) {\n  return wordDiff.diff(oldStr, newStr, options);\n}\n\nvar lineDiff = new Diff();\n\nlineDiff.tokenize = function (value) {\n  var retLines = [],\n      linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n    linesAndNewlines.pop();\n  } // Merge the content and line separators into single tokens\n\n\n  for (var i = 0; i < linesAndNewlines.length; i++) {\n    var line = linesAndNewlines[i];\n\n    if (i % 2 && !this.options.newlineIsToken) {\n      retLines[retLines.length - 1] += line;\n    } else {\n      if (this.options.ignoreWhitespace) {\n        line = line.trim();\n      }\n\n      retLines.push(line);\n    }\n  }\n\n  return retLines;\n};\n\nfunction diffLines(oldStr, newStr, callback) {\n  return lineDiff.diff(oldStr, newStr, callback);\n}\nfunction diffTrimmedLines(oldStr, newStr, callback) {\n  var options = generateOptions(callback, {\n    ignoreWhitespace: true\n  });\n  return lineDiff.diff(oldStr, newStr, options);\n}\n\nvar sentenceDiff = new Diff();\n\nsentenceDiff.tokenize = function (value) {\n  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n};\n\nfunction diffSentences(oldStr, newStr, callback) {\n  return sentenceDiff.diff(oldStr, newStr, callback);\n}\n\nvar cssDiff = new Diff();\n\ncssDiff.tokenize = function (value) {\n  return value.split(/([{}:;,]|\\s+)/);\n};\n\nfunction diffCss(oldStr, newStr, callback) {\n  return cssDiff.diff(oldStr, newStr, callback);\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar objectPrototypeToString = Object.prototype.toString;\nvar jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\njsonDiff.useLongestToken = true;\njsonDiff.tokenize = lineDiff.tokenize;\n\njsonDiff.castInput = function (value) {\n  var _this$options = this.options,\n      undefinedReplacement = _this$options.undefinedReplacement,\n      _this$options$stringi = _this$options.stringifyReplacer,\n      stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n    return typeof v === 'undefined' ? undefinedReplacement : v;\n  } : _this$options$stringi;\n  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n};\n\njsonDiff.equals = function (left, right) {\n  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n};\n\nfunction diffJson(oldObj, newObj, options) {\n  return jsonDiff.diff(oldObj, newObj, options);\n} // This function handles the presence of circular references by bailing out when encountering an\n// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\nfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n  stack = stack || [];\n  replacementStack = replacementStack || [];\n\n  if (replacer) {\n    obj = replacer(key, obj);\n  }\n\n  var i;\n\n  for (i = 0; i < stack.length; i += 1) {\n    if (stack[i] === obj) {\n      return replacementStack[i];\n    }\n  }\n\n  var canonicalizedObj;\n\n  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n    stack.push(obj);\n    canonicalizedObj = new Array(obj.length);\n    replacementStack.push(canonicalizedObj);\n\n    for (i = 0; i < obj.length; i += 1) {\n      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n    return canonicalizedObj;\n  }\n\n  if (obj && obj.toJSON) {\n    obj = obj.toJSON();\n  }\n\n  if (_typeof(obj) === 'object' && obj !== null) {\n    stack.push(obj);\n    canonicalizedObj = {};\n    replacementStack.push(canonicalizedObj);\n\n    var sortedKeys = [],\n        _key;\n\n    for (_key in obj) {\n      /* istanbul ignore else */\n      if (obj.hasOwnProperty(_key)) {\n        sortedKeys.push(_key);\n      }\n    }\n\n    sortedKeys.sort();\n\n    for (i = 0; i < sortedKeys.length; i += 1) {\n      _key = sortedKeys[i];\n      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n    }\n\n    stack.pop();\n    replacementStack.pop();\n  } else {\n    canonicalizedObj = obj;\n  }\n\n  return canonicalizedObj;\n}\n\nvar arrayDiff = new Diff();\n\narrayDiff.tokenize = function (value) {\n  return value.slice();\n};\n\narrayDiff.join = arrayDiff.removeEmpty = function (value) {\n  return value;\n};\n\nfunction diffArrays(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nfunction parsePatch(uniDiff) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      list = [],\n      i = 0;\n\n  function parseIndex() {\n    var index = {};\n    list.push(index); // Parse diff metadata\n\n    while (i < diffstr.length) {\n      var line = diffstr[i]; // File header found, end parsing diff metadata\n\n      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n        break;\n      } // Diff index\n\n\n      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n      if (header) {\n        index.index = header[1];\n      }\n\n      i++;\n    } // Parse file headers if they are defined. Unified diff requires them, but\n    // there's no technical issues to have an isolated hunk without file header\n\n\n    parseFileHeader(index);\n    parseFileHeader(index); // Parse hunks\n\n    index.hunks = [];\n\n    while (i < diffstr.length) {\n      var _line = diffstr[i];\n\n      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n        break;\n      } else if (/^@@/.test(_line)) {\n        index.hunks.push(parseHunk());\n      } else if (_line && options.strict) {\n        // Ignore unexpected content unless in strict mode\n        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n      } else {\n        i++;\n      }\n    }\n  } // Parses the --- and +++ headers, if none are found, no lines\n  // are consumed.\n\n\n  function parseFileHeader(index) {\n    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n    if (fileHeader) {\n      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n      var data = fileHeader[2].split('\\t', 2);\n      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n      if (/^\".*\"$/.test(fileName)) {\n        fileName = fileName.substr(1, fileName.length - 2);\n      }\n\n      index[keyPrefix + 'FileName'] = fileName;\n      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n      i++;\n    }\n  } // Parses a hunk\n  // This assumes that we are at the start of a hunk.\n\n\n  function parseHunk() {\n    var chunkHeaderIndex = i,\n        chunkHeaderLine = diffstr[i++],\n        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n    var hunk = {\n      oldStart: +chunkHeader[1],\n      oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n      newStart: +chunkHeader[3],\n      newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n      lines: [],\n      linedelimiters: []\n    }; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart += 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart += 1;\n    }\n\n    var addCount = 0,\n        removeCount = 0;\n\n    for (; i < diffstr.length; i++) {\n      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n      // But they could be the header for the next file. Therefore prune such cases out.\n      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n        break;\n      }\n\n      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n        hunk.lines.push(diffstr[i]);\n        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n        if (operation === '+') {\n          addCount++;\n        } else if (operation === '-') {\n          removeCount++;\n        } else if (operation === ' ') {\n          addCount++;\n          removeCount++;\n        }\n      } else {\n        break;\n      }\n    } // Handle the empty block count case\n\n\n    if (!addCount && hunk.newLines === 1) {\n      hunk.newLines = 0;\n    }\n\n    if (!removeCount && hunk.oldLines === 1) {\n      hunk.oldLines = 0;\n    } // Perform optional sanity checking\n\n\n    if (options.strict) {\n      if (addCount !== hunk.newLines) {\n        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n\n      if (removeCount !== hunk.oldLines) {\n        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n      }\n    }\n\n    return hunk;\n  }\n\n  while (i < diffstr.length) {\n    parseIndex();\n  }\n\n  return list;\n}\n\n// Iterator that traverses in the range of [min, max], stepping\n// by distance from a given start position. I.e. for [0, 4], with\n// start of 2, this will iterate 2, 3, 1, 4, 0.\nfunction distanceIterator (start, minLine, maxLine) {\n  var wantForward = true,\n      backwardExhausted = false,\n      forwardExhausted = false,\n      localOffset = 1;\n  return function iterator() {\n    if (wantForward && !forwardExhausted) {\n      if (backwardExhausted) {\n        localOffset++;\n      } else {\n        wantForward = false;\n      } // Check if trying to fit beyond text length, and if not, check it fits\n      // after offset location (or desired location on first iteration)\n\n\n      if (start + localOffset <= maxLine) {\n        return localOffset;\n      }\n\n      forwardExhausted = true;\n    }\n\n    if (!backwardExhausted) {\n      if (!forwardExhausted) {\n        wantForward = true;\n      } // Check if trying to fit before text beginning, and if not, check it fits\n      // before offset location\n\n\n      if (minLine <= start - localOffset) {\n        return -localOffset++;\n      }\n\n      backwardExhausted = true;\n      return iterator();\n    } // We tried to fit hunk before text beginning and beyond text length, then\n    // hunk can't fit on the text. Return undefined\n\n  };\n}\n\nfunction applyPatch(source, uniDiff) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n    return line === patchContent;\n  },\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n      removeEOFNL,\n      addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line;\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n\n        toPos++;\n      }\n    }\n\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n    var iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n\n  var diffOffset = 0;\n\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n          operation = line.length > 0 ? line[0] : ' ',\n          content = line.length > 0 ? line.substr(1) : line,\n          delimiter = _hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  var currentIndex = 0;\n\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n\n  processIndex();\n}\n\nfunction structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof options.context === 'undefined') {\n    options.context = 4;\n  }\n\n  var diff = diffLines(oldStr, newStr, options);\n  diff.push({\n    value: '',\n    lines: []\n  }); // Append an empty value to make cleanup easier\n\n  function contextLines(lines) {\n    return lines.map(function (entry) {\n      return ' ' + entry;\n    });\n  }\n\n  var hunks = [];\n  var oldRangeStart = 0,\n      newRangeStart = 0,\n      curRange = [],\n      oldLine = 1,\n      newLine = 1;\n\n  var _loop = function _loop(i) {\n    var current = diff[i],\n        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n    current.lines = lines;\n\n    if (current.added || current.removed) {\n      var _curRange;\n\n      // If we have previous context, start with that\n      if (!oldRangeStart) {\n        var prev = diff[i - 1];\n        oldRangeStart = oldLine;\n        newRangeStart = newLine;\n\n        if (prev) {\n          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n          oldRangeStart -= curRange.length;\n          newRangeStart -= curRange.length;\n        }\n      } // Output our changes\n\n\n      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n        return (current.added ? '+' : '-') + entry;\n      }))); // Track the updated file position\n\n\n      if (current.added) {\n        newLine += lines.length;\n      } else {\n        oldLine += lines.length;\n      }\n    } else {\n      // Identical context lines. Track line changes\n      if (oldRangeStart) {\n        // Close out any changes that have been output (or join overlapping)\n        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n          var _curRange2;\n\n          // Overlapping\n          (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n        } else {\n          var _curRange3;\n\n          // end the range and output\n          var contextSize = Math.min(lines.length, options.context);\n\n          (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n          var hunk = {\n            oldStart: oldRangeStart,\n            oldLines: oldLine - oldRangeStart + contextSize,\n            newStart: newRangeStart,\n            newLines: newLine - newRangeStart + contextSize,\n            lines: curRange\n          };\n\n          if (i >= diff.length - 2 && lines.length <= options.context) {\n            // EOF is inside this hunk\n            var oldEOFNewline = /\\n$/.test(oldStr);\n            var newEOFNewline = /\\n$/.test(newStr);\n            var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n              // special case: old has no eol and no trailing context; no-nl can end up before adds\n              // however, if the old file is empty, do not output the no-nl line\n              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n            }\n\n            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n              curRange.push('\\\\ No newline at end of file');\n            }\n          }\n\n          hunks.push(hunk);\n          oldRangeStart = 0;\n          newRangeStart = 0;\n          curRange = [];\n        }\n      }\n\n      oldLine += lines.length;\n      newLine += lines.length;\n    }\n  };\n\n  for (var i = 0; i < diff.length; i++) {\n    _loop(i);\n  }\n\n  return {\n    oldFileName: oldFileName,\n    newFileName: newFileName,\n    oldHeader: oldHeader,\n    newHeader: newHeader,\n    hunks: hunks\n  };\n}\nfunction formatPatch(diff) {\n  var ret = [];\n\n  if (diff.oldFileName == diff.newFileName) {\n    ret.push('Index: ' + diff.oldFileName);\n  }\n\n  ret.push('===================================================================');\n  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n  for (var i = 0; i < diff.hunks.length; i++) {\n    var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n    // the first number is one lower than one would expect.\n    // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n    if (hunk.oldLines === 0) {\n      hunk.oldStart -= 1;\n    }\n\n    if (hunk.newLines === 0) {\n      hunk.newStart -= 1;\n    }\n\n    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n    ret.push.apply(ret, hunk.lines);\n  }\n\n  return ret.join('\\n') + '\\n';\n}\nfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n}\nfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n}\n\nfunction arrayEqual(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return arrayStartsWith(a, b);\n}\nfunction arrayStartsWith(array, start) {\n  if (start.length > array.length) {\n    return false;\n  }\n\n  for (var i = 0; i < start.length; i++) {\n    if (start[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction calcLineCount(hunk) {\n  var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n      oldLines = _calcOldNewLineCount.oldLines,\n      newLines = _calcOldNewLineCount.newLines;\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n  var mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n      oldStart: Infinity\n    },\n        theirsCurrent = theirs.hunks[theirsIndex] || {\n      oldStart: Infinity\n    };\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n    offset: mineOffset,\n    lines: mineLines,\n    index: 0\n  },\n      their = {\n    offset: theirOffset,\n    lines: theirLines,\n    index: 0\n  }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      var _hunk$lines;\n\n      // Mine inserted\n      (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      var _hunk$lines2;\n\n      // Theirs inserted\n      (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      var _hunk$lines3;\n\n      (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      var _hunk$lines4;\n\n      (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    var _hunk$lines5;\n\n    (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n\n  if (theirChanges.merged) {\n    var _hunk$lines6;\n\n    (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\n\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  var ret = [],\n      operation = state.lines[state.index][0];\n\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\n\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n        match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\n\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}\n\n// See: http://code.google.com/p/google-diff-match-patch/wiki/API\nfunction convertChangesToDMP(changes) {\n  var ret = [],\n      change,\n      operation;\n\n  for (var i = 0; i < changes.length; i++) {\n    change = changes[i];\n\n    if (change.added) {\n      operation = 1;\n    } else if (change.removed) {\n      operation = -1;\n    } else {\n      operation = 0;\n    }\n\n    ret.push([operation, change.value]);\n  }\n\n  return ret;\n}\n\nfunction convertChangesToXML(changes) {\n  var ret = [];\n\n  for (var i = 0; i < changes.length; i++) {\n    var change = changes[i];\n\n    if (change.added) {\n      ret.push('<ins>');\n    } else if (change.removed) {\n      ret.push('<del>');\n    }\n\n    ret.push(escapeHTML(change.value));\n\n    if (change.added) {\n      ret.push('</ins>');\n    } else if (change.removed) {\n      ret.push('</del>');\n    }\n  }\n\n  return ret.join('');\n}\n\nfunction escapeHTML(s) {\n  var n = s;\n  n = n.replace(/&/g, '&amp;');\n  n = n.replace(/</g, '&lt;');\n  n = n.replace(/>/g, '&gt;');\n  n = n.replace(/\"/g, '&quot;');\n  return n;\n}\n\nexport { Diff, applyPatch, applyPatches, canonicalize, convertChangesToDMP, convertChangesToXML, createPatch, createTwoFilesPatch, diffArrays, diffChars, diffCss, diffJson, diffLines, diffSentences, diffTrimmedLines, diffWords, diffWordsWithSpace, merge, parsePatch, structuredPatch };\n"]},"metadata":{},"sourceType":"module"}