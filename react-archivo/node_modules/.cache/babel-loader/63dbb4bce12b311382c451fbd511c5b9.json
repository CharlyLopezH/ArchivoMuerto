{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport { ok as assert } from 'uvu/assert';\nimport { asciiAlpha, asciiAlphanumeric, asciiAtext, asciiControl } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 1;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.autolink);\n    effects.enter(types.autolinkMarker);\n    effects.consume(code);\n    effects.exit(types.autolinkMarker);\n    effects.enter(types.autolinkProtocol);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return schemeOrEmailAtext;\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function schemeOrEmailAtext(code) {\n    return code === codes.plusSign || code === codes.dash || code === codes.dot || asciiAlphanumeric(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);\n  }\n  /** @type {State} */\n\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === codes.colon) {\n      effects.consume(code);\n      return urlInside;\n    }\n\n    if ((code === codes.plusSign || code === codes.dash || code === codes.dot || asciiAlphanumeric(code)) && size++ < constants.autolinkSchemeSizeMax) {\n      effects.consume(code);\n      return schemeInsideOrEmailAtext;\n    }\n\n    return emailAtext(code);\n  }\n  /** @type {State} */\n\n\n  function urlInside(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.autolinkProtocol);\n      return end(code);\n    }\n\n    if (code === codes.eof || code === codes.space || code === codes.lessThan || asciiControl(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return urlInside;\n  }\n  /** @type {State} */\n\n\n  function emailAtext(code) {\n    if (code === codes.atSign) {\n      effects.consume(code);\n      size = 0;\n      return emailAtSignOrDot;\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code);\n      return emailAtext;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function emailLabel(code) {\n    if (code === codes.dot) {\n      effects.consume(code);\n      size = 0;\n      return emailAtSignOrDot;\n    }\n\n    if (code === codes.greaterThan) {\n      // Exit, then change the type.\n      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;\n      return end(code);\n    }\n\n    return emailValue(code);\n  }\n  /** @type {State} */\n\n\n  function emailValue(code) {\n    if ((code === codes.dash || asciiAlphanumeric(code)) && size++ < constants.autolinkDomainSizeMax) {\n      effects.consume(code);\n      return code === codes.dash ? emailValue : emailLabel;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    assert(code === codes.greaterThan, 'expected `>`');\n    effects.enter(types.autolinkMarker);\n    effects.consume(code);\n    effects.exit(types.autolinkMarker);\n    effects.exit(types.autolink);\n    return ok;\n  }\n}","map":{"version":3,"sources":["C:/reactjs/Udemy/NetCore/react-peliculas/node_modules/micromark-core-commonmark/dev/lib/autolink.js"],"names":["ok","assert","asciiAlpha","asciiAlphanumeric","asciiAtext","asciiControl","codes","constants","types","autolink","name","tokenize","tokenizeAutolink","effects","nok","size","start","code","lessThan","enter","autolinkMarker","consume","exit","autolinkProtocol","open","schemeOrEmailAtext","emailAtext","plusSign","dash","dot","schemeInsideOrEmailAtext","colon","urlInside","autolinkSchemeSizeMax","greaterThan","end","eof","space","atSign","emailAtSignOrDot","emailLabel","type","autolinkEmail","emailValue","autolinkDomainSizeMax"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,SAAQA,EAAE,IAAIC,MAAd,QAA2B,YAA3B;AACA,SACEC,UADF,EAEEC,iBAFF,EAGEC,UAHF,EAIEC,YAJF,QAKO,0BALP;AAMA,SAAQC,KAAR,QAAoB,gCAApB;AACA,SAAQC,SAAR,QAAwB,oCAAxB;AACA,SAAQC,KAAR,QAAoB,gCAApB;AAEA;;AACA,OAAO,MAAMC,QAAQ,GAAG;AAACC,EAAAA,IAAI,EAAE,UAAP;AAAmBC,EAAAA,QAAQ,EAAEC;AAA7B,CAAjB;AAEP;;AACA,SAASA,gBAAT,CAA0BC,OAA1B,EAAmCb,EAAnC,EAAuCc,GAAvC,EAA4C;AAC1C,MAAIC,IAAI,GAAG,CAAX;AAEA,SAAOC,KAAP;AAEA;;AACA,WAASA,KAAT,CAAeC,IAAf,EAAqB;AACnBhB,IAAAA,MAAM,CAACgB,IAAI,KAAKX,KAAK,CAACY,QAAhB,EAA0B,cAA1B,CAAN;AACAL,IAAAA,OAAO,CAACM,KAAR,CAAcX,KAAK,CAACC,QAApB;AACAI,IAAAA,OAAO,CAACM,KAAR,CAAcX,KAAK,CAACY,cAApB;AACAP,IAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACAJ,IAAAA,OAAO,CAACS,IAAR,CAAad,KAAK,CAACY,cAAnB;AACAP,IAAAA,OAAO,CAACM,KAAR,CAAcX,KAAK,CAACe,gBAApB;AACA,WAAOC,IAAP;AACD;AAED;;;AACA,WAASA,IAAT,CAAcP,IAAd,EAAoB;AAClB,QAAIf,UAAU,CAACe,IAAD,CAAd,EAAsB;AACpBJ,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACA,aAAOQ,kBAAP;AACD;;AAED,WAAOrB,UAAU,CAACa,IAAD,CAAV,GAAmBS,UAAU,CAACT,IAAD,CAA7B,GAAsCH,GAAG,CAACG,IAAD,CAAhD;AACD;AAED;;;AACA,WAASQ,kBAAT,CAA4BR,IAA5B,EAAkC;AAChC,WAAOA,IAAI,KAAKX,KAAK,CAACqB,QAAf,IACLV,IAAI,KAAKX,KAAK,CAACsB,IADV,IAELX,IAAI,KAAKX,KAAK,CAACuB,GAFV,IAGL1B,iBAAiB,CAACc,IAAD,CAHZ,GAIHa,wBAAwB,CAACb,IAAD,CAJrB,GAKHS,UAAU,CAACT,IAAD,CALd;AAMD;AAED;;;AACA,WAASa,wBAAT,CAAkCb,IAAlC,EAAwC;AACtC,QAAIA,IAAI,KAAKX,KAAK,CAACyB,KAAnB,EAA0B;AACxBlB,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACA,aAAOe,SAAP;AACD;;AAED,QACE,CAACf,IAAI,KAAKX,KAAK,CAACqB,QAAf,IACCV,IAAI,KAAKX,KAAK,CAACsB,IADhB,IAECX,IAAI,KAAKX,KAAK,CAACuB,GAFhB,IAGC1B,iBAAiB,CAACc,IAAD,CAHnB,KAIAF,IAAI,KAAKR,SAAS,CAAC0B,qBALrB,EAME;AACApB,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACA,aAAOa,wBAAP;AACD;;AAED,WAAOJ,UAAU,CAACT,IAAD,CAAjB;AACD;AAED;;;AACA,WAASe,SAAT,CAAmBf,IAAnB,EAAyB;AACvB,QAAIA,IAAI,KAAKX,KAAK,CAAC4B,WAAnB,EAAgC;AAC9BrB,MAAAA,OAAO,CAACS,IAAR,CAAad,KAAK,CAACe,gBAAnB;AACA,aAAOY,GAAG,CAAClB,IAAD,CAAV;AACD;;AAED,QACEA,IAAI,KAAKX,KAAK,CAAC8B,GAAf,IACAnB,IAAI,KAAKX,KAAK,CAAC+B,KADf,IAEApB,IAAI,KAAKX,KAAK,CAACY,QAFf,IAGAb,YAAY,CAACY,IAAD,CAJd,EAKE;AACA,aAAOH,GAAG,CAACG,IAAD,CAAV;AACD;;AAEDJ,IAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACA,WAAOe,SAAP;AACD;AAED;;;AACA,WAASN,UAAT,CAAoBT,IAApB,EAA0B;AACxB,QAAIA,IAAI,KAAKX,KAAK,CAACgC,MAAnB,EAA2B;AACzBzB,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACAF,MAAAA,IAAI,GAAG,CAAP;AACA,aAAOwB,gBAAP;AACD;;AAED,QAAInC,UAAU,CAACa,IAAD,CAAd,EAAsB;AACpBJ,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACA,aAAOS,UAAP;AACD;;AAED,WAAOZ,GAAG,CAACG,IAAD,CAAV;AACD;AAED;;;AACA,WAASsB,gBAAT,CAA0BtB,IAA1B,EAAgC;AAC9B,WAAOd,iBAAiB,CAACc,IAAD,CAAjB,GAA0BuB,UAAU,CAACvB,IAAD,CAApC,GAA6CH,GAAG,CAACG,IAAD,CAAvD;AACD;AAED;;;AACA,WAASuB,UAAT,CAAoBvB,IAApB,EAA0B;AACxB,QAAIA,IAAI,KAAKX,KAAK,CAACuB,GAAnB,EAAwB;AACtBhB,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACAF,MAAAA,IAAI,GAAG,CAAP;AACA,aAAOwB,gBAAP;AACD;;AAED,QAAItB,IAAI,KAAKX,KAAK,CAAC4B,WAAnB,EAAgC;AAC9B;AACArB,MAAAA,OAAO,CAACS,IAAR,CAAad,KAAK,CAACe,gBAAnB,EAAqCkB,IAArC,GAA4CjC,KAAK,CAACkC,aAAlD;AACA,aAAOP,GAAG,CAAClB,IAAD,CAAV;AACD;;AAED,WAAO0B,UAAU,CAAC1B,IAAD,CAAjB;AACD;AAED;;;AACA,WAAS0B,UAAT,CAAoB1B,IAApB,EAA0B;AACxB,QACE,CAACA,IAAI,KAAKX,KAAK,CAACsB,IAAf,IAAuBzB,iBAAiB,CAACc,IAAD,CAAzC,KACAF,IAAI,KAAKR,SAAS,CAACqC,qBAFrB,EAGE;AACA/B,MAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACA,aAAOA,IAAI,KAAKX,KAAK,CAACsB,IAAf,GAAsBe,UAAtB,GAAmCH,UAA1C;AACD;;AAED,WAAO1B,GAAG,CAACG,IAAD,CAAV;AACD;AAED;;;AACA,WAASkB,GAAT,CAAalB,IAAb,EAAmB;AACjBhB,IAAAA,MAAM,CAACgB,IAAI,KAAKX,KAAK,CAAC4B,WAAhB,EAA6B,cAA7B,CAAN;AACArB,IAAAA,OAAO,CAACM,KAAR,CAAcX,KAAK,CAACY,cAApB;AACAP,IAAAA,OAAO,CAACQ,OAAR,CAAgBJ,IAAhB;AACAJ,IAAAA,OAAO,CAACS,IAAR,CAAad,KAAK,CAACY,cAAnB;AACAP,IAAAA,OAAO,CAACS,IAAR,CAAad,KAAK,CAACC,QAAnB;AACA,WAAOT,EAAP;AACD;AACF","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const autolink = {name: 'autolink', tokenize: tokenizeAutolink}\n\n/** @type {Tokenizer} */\nfunction tokenizeAutolink(effects, ok, nok) {\n  let size = 1\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.autolink)\n    effects.enter(types.autolinkMarker)\n    effects.consume(code)\n    effects.exit(types.autolinkMarker)\n    effects.enter(types.autolinkProtocol)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\n  }\n\n  /** @type {State} */\n  function schemeOrEmailAtext(code) {\n    return code === codes.plusSign ||\n      code === codes.dash ||\n      code === codes.dot ||\n      asciiAlphanumeric(code)\n      ? schemeInsideOrEmailAtext(code)\n      : emailAtext(code)\n  }\n\n  /** @type {State} */\n  function schemeInsideOrEmailAtext(code) {\n    if (code === codes.colon) {\n      effects.consume(code)\n      return urlInside\n    }\n\n    if (\n      (code === codes.plusSign ||\n        code === codes.dash ||\n        code === codes.dot ||\n        asciiAlphanumeric(code)) &&\n      size++ < constants.autolinkSchemeSizeMax\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    return emailAtext(code)\n  }\n\n  /** @type {State} */\n  function urlInside(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.autolinkProtocol)\n      return end(code)\n    }\n\n    if (\n      code === codes.eof ||\n      code === codes.space ||\n      code === codes.lessThan ||\n      asciiControl(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n\n  /** @type {State} */\n  function emailAtext(code) {\n    if (code === codes.atSign) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n\n  /** @type {State} */\n  function emailLabel(code) {\n    if (code === codes.dot) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === codes.greaterThan) {\n      // Exit, then change the type.\n      effects.exit(types.autolinkProtocol).type = types.autolinkEmail\n      return end(code)\n    }\n\n    return emailValue(code)\n  }\n\n  /** @type {State} */\n  function emailValue(code) {\n    if (\n      (code === codes.dash || asciiAlphanumeric(code)) &&\n      size++ < constants.autolinkDomainSizeMax\n    ) {\n      effects.consume(code)\n      return code === codes.dash ? emailValue : emailLabel\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    assert(code === codes.greaterThan, 'expected `>`')\n    effects.enter(types.autolinkMarker)\n    effects.consume(code)\n    effects.exit(types.autolinkMarker)\n    effects.exit(types.autolink)\n    return ok\n  }\n}\n"]},"metadata":{},"sourceType":"module"}