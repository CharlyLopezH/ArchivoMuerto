{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { ok as assert } from 'uvu/assert';\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { htmlBlockNames, htmlRawNames } from 'micromark-util-html-tag-name';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { blankLine } from './blank-line.js';\n/** @type {Construct} */\n\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n};\n/** @type {Construct} */\n\nconst nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveToHtmlFlow(events) {\n  let index = events.length;\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === types.htmlFlow) {\n      break;\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start; // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start; // Remove the line prefix.\n\n    events.splice(index - 2, 2);\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this;\n  /** @type {number} */\n\n  let kind;\n  /** @type {boolean} */\n\n  let startTag;\n  /** @type {string} */\n\n  let buffer;\n  /** @type {number} */\n\n  let index;\n  /** @type {Code} */\n\n  let marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlFlow);\n    effects.enter(types.htmlFlowData);\n    effects.consume(code);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationStart;\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      kind = constants.htmlInstruction; // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      startTag = true;\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function declarationStart(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      kind = constants.htmlComment;\n      return commentOpenInside;\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      kind = constants.htmlCdata;\n      buffer = constants.cdataOpeningString;\n      index = 0;\n      return cdataOpenInside;\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      kind = constants.htmlDeclaration;\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return self.interrupt ? ok : continuationDeclarationInside;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === buffer.length ? self.interrupt ? ok : continuation : cdataOpenInside;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagName(code) {\n    if (code === codes.eof || code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      if (code !== codes.slash && startTag && htmlRawNames.includes(buffer.toLowerCase())) {\n        kind = constants.htmlRaw;\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = constants.htmlBasic;\n\n        if (code === codes.slash) {\n          effects.consume(code);\n          return basicSelfClosing;\n        }\n\n        return self.interrupt ? ok(code) : continuation(code);\n      }\n\n      kind = constants.htmlComplete; // Do not support complete HTML when interrupting\n\n      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);\n    }\n\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return tagName;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return self.interrupt ? ok : continuation;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeClosingTagAfter;\n    }\n\n    return completeEnd(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return completeEnd;\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameBefore;\n    }\n\n    return completeEnd(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeName(code) {\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n\n    return completeAttributeNameAfter(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameAfter;\n    }\n\n    return completeAttributeNameBefore(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      marker = code;\n      return completeAttributeValueQuoted;\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n\n    marker = null;\n    return completeAttributeValueUnquoted(code);\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueQuoted(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code);\n    }\n\n    if (code === marker) {\n      effects.consume(code);\n      return completeAttributeValueQuotedAfter;\n    }\n\n    effects.consume(code);\n    return completeAttributeValueQuoted;\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || markdownLineEndingOrSpace(code)) {\n      return completeAttributeNameAfter(code);\n    }\n\n    effects.consume(code);\n    return completeAttributeValueUnquoted;\n  }\n  /** @type {State} */\n\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownSpace(code)) {\n      return completeAttributeNameBefore(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAfter;\n    }\n\n    return code === codes.eof || markdownLineEnding(code) ? continuation(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function continuation(code) {\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code);\n      return continuationCommentInside;\n    }\n\n    if (code === codes.lessThan && kind === constants.htmlRaw) {\n      effects.consume(code);\n      return continuationRawTagOpen;\n    }\n\n    if (code === codes.greaterThan && kind === constants.htmlDeclaration) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    if (code === codes.questionMark && kind === constants.htmlInstruction) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    if (code === codes.rightSquareBracket && kind === constants.htmlCdata) {\n      effects.consume(code);\n      return continuationCharacterDataInside;\n    }\n\n    if (markdownLineEnding(code) && (kind === constants.htmlBasic || kind === constants.htmlComplete)) {\n      return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code);\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code);\n    }\n\n    effects.consume(code);\n    return continuation;\n  }\n  /** @type {State} */\n\n\n  function continuationAtLineEnding(code) {\n    effects.exit(types.htmlFlowData);\n    return htmlContinueStart(code);\n  }\n  /** @type {State} */\n\n\n  function htmlContinueStart(code) {\n    if (code === codes.eof) {\n      return done(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt({\n        tokenize: htmlLineEnd,\n        partial: true\n      }, htmlContinueStart, done)(code);\n    }\n\n    effects.enter(types.htmlFlowData);\n    return continuation(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function htmlLineEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {State} */\n\n\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      buffer = '';\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan && htmlRawNames.includes(buffer.toLowerCase())) {\n      effects.consume(code);\n      return continuationClose;\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return continuationRawEndTag;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationCharacterDataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return continuationClose;\n    } // More dashes.\n\n\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n\n    return continuation(code);\n  }\n  /** @type {State} */\n\n\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return done(code);\n    }\n\n    effects.consume(code);\n    return continuationClose;\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    effects.exit(types.htmlFlow);\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending');\n    effects.exit(types.htmlFlowData);\n    effects.enter(types.lineEndingBlank);\n    effects.consume(code);\n    effects.exit(types.lineEndingBlank);\n    return effects.attempt(blankLine, ok, nok);\n  }\n}","map":{"version":3,"sources":["C:/reactjs/Udemy/NetCore/react-peliculas/node_modules/micromark-core-commonmark/dev/lib/html-flow.js"],"names":["ok","assert","asciiAlpha","asciiAlphanumeric","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","htmlBlockNames","htmlRawNames","codes","constants","types","blankLine","htmlFlow","name","tokenize","tokenizeHtmlFlow","resolveTo","resolveToHtmlFlow","concrete","nextBlankConstruct","tokenizeNextBlank","partial","events","index","length","type","linePrefix","start","splice","effects","nok","self","kind","startTag","buffer","marker","code","lessThan","enter","htmlFlowData","consume","open","exclamationMark","declarationStart","slash","tagCloseStart","questionMark","htmlInstruction","interrupt","continuationDeclarationInside","String","fromCharCode","tagName","dash","htmlComment","commentOpenInside","leftSquareBracket","htmlCdata","cdataOpeningString","cdataOpenInside","htmlDeclaration","charCodeAt","continuation","eof","greaterThan","includes","toLowerCase","htmlRaw","htmlBasic","basicSelfClosing","htmlComplete","parser","lazy","now","line","completeAttributeNameBefore","completeClosingTagAfter","completeEnd","colon","underscore","completeAttributeName","dot","completeAttributeNameAfter","equalsTo","completeAttributeValueBefore","graveAccent","quotationMark","apostrophe","completeAttributeValueQuoted","completeAttributeValueUnquoted","completeAttributeValueQuotedAfter","completeAfter","continuationCommentInside","continuationRawTagOpen","continuationClose","rightSquareBracket","continuationCharacterDataInside","check","continuationAtLineEnding","exit","htmlContinueStart","done","attempt","htmlLineEnd","lineEnding","lineStart","continuationRawEndTag","htmlRawSizeMax","lineEndingBlank"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {htmlBlockNames, htmlRawNames} from 'micromark-util-html-tag-name'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {blankLine} from './blank-line.js'\n\n/** @type {Construct} */\nexport const htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nextBlankConstruct = {tokenize: tokenizeNextBlank, partial: true}\n\n/** @type {Resolver} */\nfunction resolveToHtmlFlow(events) {\n  let index = events.length\n\n  while (index--) {\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === types.htmlFlow\n    ) {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start\n    // Add the prefix start to the HTML line token.\n    events[index + 1][1].start = events[index - 2][1].start\n    // Remove the line prefix.\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  const self = this\n  /** @type {number} */\n  let kind\n  /** @type {boolean} */\n  let startTag\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {Code} */\n  let marker\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlFlow)\n    effects.enter(types.htmlFlowData)\n    effects.consume(code)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      kind = constants.htmlInstruction\n      // While we’re in an instruction instead of a declaration, we’re on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function declarationStart(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      kind = constants.htmlComment\n      return commentOpenInside\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      kind = constants.htmlCdata\n      buffer = constants.cdataOpeningString\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = constants.htmlDeclaration\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagName(code) {\n    if (\n      code === codes.eof ||\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== codes.slash &&\n        startTag &&\n        htmlRawNames.includes(buffer.toLowerCase())\n      ) {\n        kind = constants.htmlRaw\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        kind = constants.htmlBasic\n\n        if (code === codes.slash) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = constants.htmlComplete\n      // Do not support complete HTML when interrupting\n      return self.interrupt && !self.parser.lazy[self.now().line]\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeName(code) {\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = null\n    return completeAttributeValueUnquoted(code)\n  }\n\n  /** @type {State} */\n  function completeAttributeValueQuoted(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  /** @type {State} */\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  /** @type {State} */\n  function completeAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownSpace(code)\n    ) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === codes.eof || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n\n  /** @type {State} */\n  function continuation(code) {\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === codes.lessThan && kind === constants.htmlRaw) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === codes.greaterThan && kind === constants.htmlDeclaration) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === codes.questionMark && kind === constants.htmlInstruction) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === codes.rightSquareBracket && kind === constants.htmlCdata) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (\n      markdownLineEnding(code) &&\n      (kind === constants.htmlBasic || kind === constants.htmlComplete)\n    ) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  /** @type {State} */\n  function continuationAtLineEnding(code) {\n    effects.exit(types.htmlFlowData)\n    return htmlContinueStart(code)\n  }\n\n  /** @type {State} */\n  function htmlContinueStart(code) {\n    if (code === codes.eof) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        {tokenize: htmlLineEnd, partial: true},\n        htmlContinueStart,\n        done\n      )(code)\n    }\n\n    effects.enter(types.htmlFlowData)\n    return continuation(code)\n  }\n\n  /** @type {Tokenizer} */\n  function htmlLineEnd(effects, ok, nok) {\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return lineStart\n    }\n\n    /** @type {State} */\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n\n  /** @type {State} */\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationRawEndTag(code) {\n    if (\n      code === codes.greaterThan &&\n      htmlRawNames.includes(buffer.toLowerCase())\n    ) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      effects.consume(code)\n      buffer += String.fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationCharacterDataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    // More dashes.\n    if (code === codes.dash && kind === constants.htmlComment) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  /** @type {State} */\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData)\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  /** @type {State} */\n  function done(code) {\n    effects.exit(types.htmlFlow)\n    return ok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected a line ending')\n    effects.exit(types.htmlFlowData)\n    effects.enter(types.lineEndingBlank)\n    effects.consume(code)\n    effects.exit(types.lineEndingBlank)\n    return effects.attempt(blankLine, ok, nok)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}