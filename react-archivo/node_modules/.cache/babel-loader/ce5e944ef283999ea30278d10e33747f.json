{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { asciiAlpha, asciiAlphanumeric, markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this;\n  /** @type {NonNullable<Code>|undefined} */\n\n  let marker;\n  /** @type {string} */\n\n  let buffer;\n  /** @type {number} */\n\n  let index;\n  /** @type {State} */\n\n  let returnState;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`');\n    effects.enter(types.htmlText);\n    effects.enter(types.htmlTextData);\n    effects.consume(code);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instruction;\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentOpen;\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      buffer = constants.cdataOpeningString;\n      index = 0;\n      return cdataOpen;\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return declaration;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function commentOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentStart;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function commentStart(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code);\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentStartDash;\n    }\n\n    return comment(code);\n  }\n  /** @type {State} */\n\n\n  function commentStartDash(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code);\n    }\n\n    return comment(code);\n  }\n  /** @type {State} */\n\n\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentClose;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return comment;\n  }\n  /** @type {State} */\n\n\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return end;\n    }\n\n    return comment(code);\n  }\n  /** @type {State} */\n\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === buffer.length ? cdata : cdataOpen;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataClose;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return cdata;\n  }\n  /** @type {State} */\n\n\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n\n    return cdata(code);\n  }\n  /** @type {State} */\n\n\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code);\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n\n    return cdata(code);\n  }\n  /** @type {State} */\n\n\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return declaration;\n  }\n  /** @type {State} */\n\n\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instructionClose;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return instruction;\n  }\n  /** @type {State} */\n\n\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code);\n  }\n  /** @type {State} */\n\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagClose(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n\n    return tagCloseBetween(code);\n  }\n  /** @type {State} */\n\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween;\n      return atLineEnding(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagCloseBetween;\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpen(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return end;\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween;\n      return atLineEnding(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenBetween;\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeName(code) {\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n\n    return tagOpenAttributeNameAfter(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter;\n      return atLineEnding(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeNameAfter;\n    }\n\n    return tagOpenBetween(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      marker = code;\n      return tagOpenAttributeValueQuoted;\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore;\n      return atLineEnding(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n\n    effects.consume(code);\n    marker = undefined;\n    return tagOpenAttributeValueUnquoted;\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return tagOpenAttributeValueQuotedAfter;\n    }\n\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted;\n      return atLineEnding(code);\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueQuoted;\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === codes.greaterThan || code === codes.slash || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.graveAccent) {\n      return nok(code);\n    }\n\n    if (code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  } // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  /** @type {State} */\n\n\n  function atLineEnding(code) {\n    assert(returnState, 'expected return state');\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.exit(types.htmlTextData);\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return factorySpace(effects, afterPrefix, types.linePrefix, self.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n  }\n  /** @type {State} */\n\n\n  function afterPrefix(code) {\n    effects.enter(types.htmlTextData);\n    return returnState(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      effects.exit(types.htmlTextData);\n      effects.exit(types.htmlText);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["C:/reactjs/projects/contra/archivo/react-archivo/node_modules/micromark-core-commonmark/dev/lib/html-text.js"],"names":["ok","assert","factorySpace","asciiAlpha","asciiAlphanumeric","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","codes","constants","types","htmlText","name","tokenize","tokenizeHtmlText","effects","nok","self","marker","buffer","index","returnState","start","code","lessThan","enter","htmlTextData","consume","open","exclamationMark","declarationOpen","slash","tagCloseStart","questionMark","instruction","tagOpen","dash","commentOpen","leftSquareBracket","cdataOpeningString","cdataOpen","declaration","commentStart","eof","greaterThan","commentStartDash","comment","commentClose","atLineEnding","end","charCodeAt","length","cdata","rightSquareBracket","cdataClose","cdataEnd","instructionClose","tagClose","tagCloseBetween","tagOpenBetween","colon","underscore","tagOpenAttributeName","dot","tagOpenAttributeNameAfter","equalsTo","tagOpenAttributeValueBefore","graveAccent","quotationMark","apostrophe","tagOpenAttributeValueQuoted","undefined","tagOpenAttributeValueUnquoted","tagOpenAttributeValueQuotedAfter","exit","lineEnding","afterPrefix","linePrefix","parser","constructs","disable","null","includes","tabSize"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const htmlText = {name: 'htmlText', tokenize: tokenizeHtmlText}\n\n/** @type {Tokenizer} */\nfunction tokenizeHtmlText(effects, ok, nok) {\n  const self = this\n  /** @type {NonNullable<Code>|undefined} */\n  let marker\n  /** @type {string} */\n  let buffer\n  /** @type {number} */\n  let index\n  /** @type {State} */\n  let returnState\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.lessThan, 'expected `<`')\n    effects.enter(types.htmlText)\n    effects.enter(types.htmlTextData)\n    effects.consume(code)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === codes.slash) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code)\n      buffer = constants.cdataOpeningString\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function commentOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function commentStart(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code)\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n\n  /** @type {State} */\n  function commentStartDash(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n\n  /** @type {State} */\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.dash) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n\n  /** @type {State} */\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n\n  /** @type {State} */\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n\n  /** @type {State} */\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /** @type {State} */\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  /** @type {State} */\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n\n  /** @type {State} */\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (code === codes.questionMark) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n\n  /** @type {State} */\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code)\n  }\n\n  /** @type {State} */\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagClose(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n\n  /** @type {State} */\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function tagOpen(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (\n      code === codes.slash ||\n      code === codes.greaterThan ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeName(code) {\n    if (\n      code === codes.dash ||\n      code === codes.dot ||\n      code === codes.colon ||\n      code === codes.underscore ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.greaterThan ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (\n      code === codes.greaterThan ||\n      code === codes.slash ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === codes.eof ||\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.lessThan ||\n      code === codes.equalsTo ||\n      code === codes.graveAccent\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  }\n\n  // We can’t have blank lines in content, so no need to worry about empty\n  // tokens.\n  /** @type {State} */\n  function atLineEnding(code) {\n    assert(returnState, 'expected return state')\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit(types.htmlTextData)\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return factorySpace(\n      effects,\n      afterPrefix,\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : constants.tabSize\n    )\n  }\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    effects.enter(types.htmlTextData)\n    return returnState(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code)\n      effects.exit(types.htmlTextData)\n      effects.exit(types.htmlText)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}