{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState;\n      assert(state, 'expected `containerState` to be defined in container');\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {\n          _container: true\n        });\n        state.open = true;\n      }\n\n      effects.enter(types.blockQuotePrefix);\n      effects.enter(types.blockQuoteMarker);\n      effects.consume(code);\n      effects.exit(types.blockQuoteMarker);\n      return after;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace);\n      effects.consume(code);\n      effects.exit(types.blockQuotePrefixWhitespace);\n      effects.exit(types.blockQuotePrefix);\n      return ok;\n    }\n\n    effects.exit(types.blockQuotePrefix);\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(effects, effects.attempt(blockQuote, ok, nok), types.linePrefix, this.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n}\n/** @type {Exiter} */\n\n\nfunction exit(effects) {\n  effects.exit(types.blockQuote);\n}","map":{"version":3,"sources":["C:/reactjs/projects/contra/archivo/react-archivo/node_modules/micromark-core-commonmark/dev/lib/block-quote.js"],"names":["ok","assert","factorySpace","markdownSpace","codes","constants","types","blockQuote","name","tokenize","tokenizeBlockQuoteStart","continuation","tokenizeBlockQuoteContinuation","exit","effects","nok","self","start","code","greaterThan","state","containerState","open","enter","_container","blockQuotePrefix","blockQuoteMarker","consume","after","blockQuotePrefixWhitespace","attempt","linePrefix","parser","constructs","disable","null","includes","undefined","tabSize"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,EAAE,IAAIC,MAAd,QAA2B,YAA3B;AACA,SAAQC,YAAR,QAA2B,yBAA3B;AACA,SAAQC,aAAR,QAA4B,0BAA5B;AACA,SAAQC,KAAR,QAAoB,gCAApB;AACA,SAAQC,SAAR,QAAwB,oCAAxB;AACA,SAAQC,KAAR,QAAoB,gCAApB;AAEA;;AACA,OAAO,MAAMC,UAAU,GAAG;AACxBC,EAAAA,IAAI,EAAE,YADkB;AAExBC,EAAAA,QAAQ,EAAEC,uBAFc;AAGxBC,EAAAA,YAAY,EAAE;AAACF,IAAAA,QAAQ,EAAEG;AAAX,GAHU;AAIxBC,EAAAA;AAJwB,CAAnB;AAOP;;AACA,SAASH,uBAAT,CAAiCI,OAAjC,EAA0Cd,EAA1C,EAA8Ce,GAA9C,EAAmD;AACjD,QAAMC,IAAI,GAAG,IAAb;AAEA,SAAOC,KAAP;AAEA;;AACA,WAASA,KAAT,CAAeC,IAAf,EAAqB;AACnB,QAAIA,IAAI,KAAKd,KAAK,CAACe,WAAnB,EAAgC;AAC9B,YAAMC,KAAK,GAAGJ,IAAI,CAACK,cAAnB;AAEApB,MAAAA,MAAM,CAACmB,KAAD,EAAQ,sDAAR,CAAN;;AAEA,UAAI,CAACA,KAAK,CAACE,IAAX,EAAiB;AACfR,QAAAA,OAAO,CAACS,KAAR,CAAcjB,KAAK,CAACC,UAApB,EAAgC;AAACiB,UAAAA,UAAU,EAAE;AAAb,SAAhC;AACAJ,QAAAA,KAAK,CAACE,IAAN,GAAa,IAAb;AACD;;AAEDR,MAAAA,OAAO,CAACS,KAAR,CAAcjB,KAAK,CAACmB,gBAApB;AACAX,MAAAA,OAAO,CAACS,KAAR,CAAcjB,KAAK,CAACoB,gBAApB;AACAZ,MAAAA,OAAO,CAACa,OAAR,CAAgBT,IAAhB;AACAJ,MAAAA,OAAO,CAACD,IAAR,CAAaP,KAAK,CAACoB,gBAAnB;AACA,aAAOE,KAAP;AACD;;AAED,WAAOb,GAAG,CAACG,IAAD,CAAV;AACD;AAED;;;AACA,WAASU,KAAT,CAAeV,IAAf,EAAqB;AACnB,QAAIf,aAAa,CAACe,IAAD,CAAjB,EAAyB;AACvBJ,MAAAA,OAAO,CAACS,KAAR,CAAcjB,KAAK,CAACuB,0BAApB;AACAf,MAAAA,OAAO,CAACa,OAAR,CAAgBT,IAAhB;AACAJ,MAAAA,OAAO,CAACD,IAAR,CAAaP,KAAK,CAACuB,0BAAnB;AACAf,MAAAA,OAAO,CAACD,IAAR,CAAaP,KAAK,CAACmB,gBAAnB;AACA,aAAOzB,EAAP;AACD;;AAEDc,IAAAA,OAAO,CAACD,IAAR,CAAaP,KAAK,CAACmB,gBAAnB;AACA,WAAOzB,EAAE,CAACkB,IAAD,CAAT;AACD;AACF;AAED;;;AACA,SAASN,8BAAT,CAAwCE,OAAxC,EAAiDd,EAAjD,EAAqDe,GAArD,EAA0D;AACxD,SAAOb,YAAY,CACjBY,OADiB,EAEjBA,OAAO,CAACgB,OAAR,CAAgBvB,UAAhB,EAA4BP,EAA5B,EAAgCe,GAAhC,CAFiB,EAGjBT,KAAK,CAACyB,UAHW,EAIjB,KAAKC,MAAL,CAAYC,UAAZ,CAAuBC,OAAvB,CAA+BC,IAA/B,CAAoCC,QAApC,CAA6C,cAA7C,IACIC,SADJ,GAEIhC,SAAS,CAACiC,OANG,CAAnB;AAQD;AAED;;;AACA,SAASzB,IAAT,CAAcC,OAAd,EAAuB;AACrBA,EAAAA,OAAO,CAACD,IAAR,CAAaP,KAAK,CAACC,UAAnB;AACD","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {tokenize: tokenizeBlockQuoteContinuation},\n  exit\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState\n\n      assert(state, 'expected `containerState` to be defined in container')\n\n      if (!state.open) {\n        effects.enter(types.blockQuote, {_container: true})\n        state.open = true\n      }\n\n      effects.enter(types.blockQuotePrefix)\n      effects.enter(types.blockQuoteMarker)\n      effects.consume(code)\n      effects.exit(types.blockQuoteMarker)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace)\n      effects.consume(code)\n      effects.exit(types.blockQuotePrefixWhitespace)\n      effects.exit(types.blockQuotePrefix)\n      return ok\n    }\n\n    effects.exit(types.blockQuotePrefix)\n    return ok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    types.linePrefix,\n    this.parser.constructs.disable.null.includes('codeIndented')\n      ? undefined\n      : constants.tabSize\n  )\n}\n\n/** @type {Exiter} */\nfunction exit(effects) {\n  effects.exit(types.blockQuote)\n}\n"]},"metadata":{},"sourceType":"module"}