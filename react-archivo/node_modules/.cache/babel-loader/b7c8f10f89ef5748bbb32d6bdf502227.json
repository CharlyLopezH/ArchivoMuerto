{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this;\n  /** @type {Construct} */\n\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n  /** @type {Construct} */\n\n  const nonLazyLine = {\n    tokenize: tokenizeNonLazyLine,\n    partial: true\n  };\n  const tail = this.events[this.events.length - 1];\n  const initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  /** @type {NonNullable<Code>} */\n\n  let marker;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.graveAccent || code === codes.tilde, 'expected `` ` `` or `~`');\n    effects.enter(types.codeFenced);\n    effects.enter(types.codeFencedFence);\n    effects.enter(types.codeFencedFenceSequence);\n    marker = code;\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit(types.codeFencedFenceSequence);\n    return sizeOpen < constants.codeFencedSequenceSizeMin ? nok(code) : factorySpace(effects, infoOpen, types.whitespace)(code);\n  }\n  /** @type {State} */\n\n\n  function infoOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter(types.codeFencedFenceInfo);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return info(code);\n  }\n  /** @type {State} */\n\n\n  function info(code) {\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceInfo);\n      return factorySpace(effects, infoAfter, types.whitespace)(code);\n    }\n\n    if (code === codes.graveAccent && code === marker) return nok(code);\n    effects.consume(code);\n    return info;\n  }\n  /** @type {State} */\n\n\n  function infoAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter(types.codeFencedFenceMeta);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceMeta);\n      return openAfter(code);\n    }\n\n    if (code === codes.graveAccent && code === marker) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit(types.codeFencedFence);\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt(closingFenceConstruct, after, initialPrefix ? factorySpace(effects, contentStart, types.linePrefix, initialPrefix + 1) : contentStart), after)(code);\n    }\n\n    effects.enter(types.codeFlowValue);\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue);\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit(types.codeFenced);\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return lineStart;\n    }\n    /** @type {State} */\n\n\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n    }\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return factorySpace(effects, closingSequenceStart, types.linePrefix, this.parser.constructs.disable.null.includes('codeIndented') ? undefined : constants.tabSize);\n    /** @type {State} */\n\n    function closingSequenceStart(code) {\n      effects.enter(types.codeFencedFence);\n      effects.enter(types.codeFencedFenceSequence);\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit(types.codeFencedFenceSequence);\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence);\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}","map":{"version":3,"sources":["C:/reactjs/Udemy/NetCore/react-peliculas/node_modules/micromark-core-commonmark/dev/lib/code-fenced.js"],"names":["ok","assert","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","codes","constants","types","codeFenced","name","tokenize","tokenizeCodeFenced","concrete","effects","nok","self","closingFenceConstruct","tokenizeClosingFence","partial","nonLazyLine","tokenizeNonLazyLine","tail","events","length","initialPrefix","type","linePrefix","sliceSerialize","sizeOpen","marker","start","code","graveAccent","tilde","enter","codeFencedFence","codeFencedFenceSequence","sequenceOpen","consume","exit","codeFencedSequenceSizeMin","infoOpen","whitespace","eof","openAfter","codeFencedFenceInfo","chunkString","contentType","contentTypeString","info","infoAfter","codeFencedFenceMeta","meta","interrupt","contentStart","after","attempt","codeFlowValue","contentContinue","lineEnding","lineStart","parser","lazy","now","line","size","closingSequenceStart","constructs","disable","null","includes","undefined","tabSize","closingSequence","closingSequenceEnd"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  const self = this\n  /** @type {Construct} */\n  const closingFenceConstruct = {tokenize: tokenizeClosingFence, partial: true}\n  /** @type {Construct} */\n  const nonLazyLine = {tokenize: tokenizeNonLazyLine, partial: true}\n  const tail = this.events[this.events.length - 1]\n  const initialPrefix =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n  /** @type {NonNullable<Code>} */\n  let marker\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(\n      code === codes.graveAccent || code === codes.tilde,\n      'expected `` ` `` or `~`'\n    )\n    effects.enter(types.codeFenced)\n    effects.enter(types.codeFencedFence)\n    effects.enter(types.codeFencedFenceSequence)\n    marker = code\n    return sequenceOpen(code)\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit(types.codeFencedFenceSequence)\n    return sizeOpen < constants.codeFencedSequenceSizeMin\n      ? nok(code)\n      : factorySpace(effects, infoOpen, types.whitespace)(code)\n  }\n\n  /** @type {State} */\n  function infoOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter(types.codeFencedFenceInfo)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return info(code)\n  }\n\n  /** @type {State} */\n  function info(code) {\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceInfo)\n      return factorySpace(effects, infoAfter, types.whitespace)(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n\n  /** @type {State} */\n  function infoAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter(types.codeFencedFenceMeta)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /** @type {State} */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit(types.codeFencedFenceMeta)\n      return openAfter(code)\n    }\n\n    if (code === codes.graveAccent && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit(types.codeFencedFence)\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          closingFenceConstruct,\n          after,\n          initialPrefix\n            ? factorySpace(\n                effects,\n                contentStart,\n                types.linePrefix,\n                initialPrefix + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter(types.codeFlowValue)\n    return contentContinue(code)\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue)\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit(types.codeFenced)\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeNonLazyLine(effects, ok, nok) {\n    const self = this\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return lineStart\n    }\n\n    /** @type {State} */\n    function lineStart(code) {\n      return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      types.linePrefix,\n      this.parser.constructs.disable.null.includes('codeIndented')\n        ? undefined\n        : constants.tabSize\n    )\n\n    /** @type {State} */\n    function closingSequenceStart(code) {\n      effects.enter(types.codeFencedFence)\n      effects.enter(types.codeFencedFenceSequence)\n      return closingSequence(code)\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit(types.codeFencedFenceSequence)\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code)\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(types.codeFencedFence)\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}