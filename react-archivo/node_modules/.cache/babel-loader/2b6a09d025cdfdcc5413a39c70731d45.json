{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Chunk[]}\n */\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nconst search = /[\\0\\t\\n\\r]/g;\n/**\n * @returns {Preprocessor}\n */\n\nexport function preprocess() {\n  let column = 1;\n  let buffer = '';\n  /** @type {boolean|undefined} */\n\n  let start = true;\n  /** @type {boolean|undefined} */\n\n  let atCarriageReturn;\n  return preprocessor;\n  /** @type {Preprocessor} */\n\n  function preprocessor(value, encoding, end) {\n    /** @type {Chunk[]} */\n    const chunks = [];\n    /** @type {RegExpMatchArray|null} */\n\n    let match;\n    /** @type {number} */\n\n    let next;\n    /** @type {number} */\n\n    let startPosition;\n    /** @type {number} */\n\n    let endPosition;\n    /** @type {Code} */\n\n    let code; // @ts-expect-error `Buffer` does allow an encoding.\n\n    value = buffer + value.toString(encoding);\n    startPosition = 0;\n    buffer = '';\n\n    if (start) {\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\n        startPosition++;\n      }\n\n      start = undefined;\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition;\n      match = search.exec(value);\n      endPosition = match && match.index !== undefined ? match.index : value.length;\n      code = value.charCodeAt(endPosition);\n\n      if (!match) {\n        buffer = value.slice(startPosition);\n        break;\n      }\n\n      if (code === codes.lf && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(codes.carriageReturnLineFeed);\n        atCarriageReturn = undefined;\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(codes.carriageReturn);\n          atCarriageReturn = undefined;\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition));\n          column += endPosition - startPosition;\n        }\n\n        switch (code) {\n          case codes.nul:\n            {\n              chunks.push(codes.replacementCharacter);\n              column++;\n              break;\n            }\n\n          case codes.ht:\n            {\n              next = Math.ceil(column / constants.tabSize) * constants.tabSize;\n              chunks.push(codes.horizontalTab);\n\n              while (column++ < next) chunks.push(codes.virtualSpace);\n\n              break;\n            }\n\n          case codes.lf:\n            {\n              chunks.push(codes.lineFeed);\n              column = 1;\n              break;\n            }\n\n          default:\n            {\n              atCarriageReturn = true;\n              column = 1;\n            }\n        }\n      }\n\n      startPosition = endPosition + 1;\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(codes.carriageReturn);\n      if (buffer) chunks.push(buffer);\n      chunks.push(codes.eof);\n    }\n\n    return chunks;\n  }\n}","map":{"version":3,"sources":["C:/reactjs/projects/contra/archivo/react-archivo/node_modules/micromark/dev/lib/preprocess.js"],"names":["codes","constants","search","preprocess","column","buffer","start","atCarriageReturn","preprocessor","value","encoding","end","chunks","match","next","startPosition","endPosition","code","toString","charCodeAt","byteOrderMarker","undefined","length","lastIndex","exec","index","slice","lf","push","carriageReturnLineFeed","carriageReturn","nul","replacementCharacter","ht","Math","ceil","tabSize","horizontalTab","virtualSpace","lineFeed","eof"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Encoding} Encoding\n * @typedef {import('micromark-util-types').Value} Value\n * @typedef {import('micromark-util-types').Chunk} Chunk\n * @typedef {import('micromark-util-types').Code} Code\n */\n\n/**\n * @callback Preprocessor\n * @param {Value} value\n * @param {Encoding} [encoding]\n * @param {boolean} [end=false]\n * @returns {Chunk[]}\n */\n\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\n\nconst search = /[\\0\\t\\n\\r]/g\n\n/**\n * @returns {Preprocessor}\n */\nexport function preprocess() {\n  let column = 1\n  let buffer = ''\n  /** @type {boolean|undefined} */\n  let start = true\n  /** @type {boolean|undefined} */\n  let atCarriageReturn\n\n  return preprocessor\n\n  /** @type {Preprocessor} */\n  function preprocessor(value, encoding, end) {\n    /** @type {Chunk[]} */\n    const chunks = []\n    /** @type {RegExpMatchArray|null} */\n    let match\n    /** @type {number} */\n    let next\n    /** @type {number} */\n    let startPosition\n    /** @type {number} */\n    let endPosition\n    /** @type {Code} */\n    let code\n\n    // @ts-expect-error `Buffer` does allow an encoding.\n    value = buffer + value.toString(encoding)\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      if (value.charCodeAt(0) === codes.byteOrderMarker) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition =\n        match && match.index !== undefined ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (\n        code === codes.lf &&\n        startPosition === endPosition &&\n        atCarriageReturn\n      ) {\n        chunks.push(codes.carriageReturnLineFeed)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(codes.carriageReturn)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        switch (code) {\n          case codes.nul: {\n            chunks.push(codes.replacementCharacter)\n            column++\n\n            break\n          }\n\n          case codes.ht: {\n            next = Math.ceil(column / constants.tabSize) * constants.tabSize\n            chunks.push(codes.horizontalTab)\n            while (column++ < next) chunks.push(codes.virtualSpace)\n\n            break\n          }\n\n          case codes.lf: {\n            chunks.push(codes.lineFeed)\n            column = 1\n\n            break\n          }\n\n          default: {\n            atCarriageReturn = true\n            column = 1\n          }\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(codes.carriageReturn)\n      if (buffer) chunks.push(buffer)\n      chunks.push(codes.eof)\n    }\n\n    return chunks\n  }\n}\n"]},"metadata":{},"sourceType":"module"}