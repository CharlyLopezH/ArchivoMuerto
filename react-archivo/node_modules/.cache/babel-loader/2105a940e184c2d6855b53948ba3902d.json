{"ast":null,"code":"import { dequal } from 'dequal';\nimport { compare, lines } from 'uvu/diff';\n\nfunction dedent(str) {\n  str = str.replace(/\\r?\\n/g, '\\n');\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm);\n  let i = 0,\n      min = 1 / 0,\n      len = (arr || []).length;\n\n  for (; i < len; i++) min = Math.min(min, arr[i].length);\n\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '') : str;\n}\n\nexport class Assertion extends Error {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(opts.message);\n    this.name = 'Assertion';\n    this.code = 'ERR_ASSERTION';\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n\n    this.details = opts.details || false;\n    this.generated = !!opts.generated;\n    this.operator = opts.operator;\n    this.expects = opts.expects;\n    this.actual = opts.actual;\n  }\n\n}\n\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n  if (bool) return;\n  let message = msg || backup;\n  if (msg instanceof Error) throw msg;\n  let details = detailer && detailer(actual, expects);\n  throw new Assertion({\n    actual,\n    expects,\n    operator,\n    message,\n    details,\n    generated: !msg\n  });\n}\n\nexport function ok(val, msg) {\n  assert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\n}\nexport function is(val, exp, msg) {\n  assert(val === exp, val, exp, 'is', compare, 'Expected values to be strictly equal:', msg);\n}\nexport function equal(val, exp, msg) {\n  assert(dequal(val, exp), val, exp, 'equal', compare, 'Expected values to be deeply equal:', msg);\n}\nexport function unreachable(msg) {\n  assert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\n}\nexport function type(val, exp, msg) {\n  let tmp = typeof val;\n  assert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\nexport function instance(val, exp, msg) {\n  let name = '`' + (exp.name || exp.constructor.name) + '`';\n  assert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\n}\nexport function match(val, exp, msg) {\n  if (typeof exp === 'string') {\n    assert(val.includes(exp), val, exp, 'match', false, `Expected value to include \"${exp}\" substring`, msg);\n  } else {\n    assert(exp.test(val), val, exp, 'match', false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\n  }\n}\nexport function snapshot(val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val === exp, val, exp, 'snapshot', lines, 'Expected value to match snapshot:', msg);\n}\n\nconst lineNums = (x, y) => lines(x, y, 1);\n\nexport function fixture(val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\n}\nexport function throws(blk, exp, msg) {\n  if (!msg && typeof exp === 'string') {\n    msg = exp;\n    exp = null;\n  }\n\n  try {\n    blk();\n    assert(false, false, true, 'throws', false, 'Expected function to throw', msg);\n  } catch (err) {\n    if (err instanceof Assertion) throw err;\n\n    if (typeof exp === 'function') {\n      assert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\n    } else if (exp instanceof RegExp) {\n      assert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n    }\n  }\n} // ---\n\nexport function not(val, msg) {\n  assert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\n}\nnot.ok = not;\n\nis.not = function (val, exp, msg) {\n  assert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\n};\n\nnot.equal = function (val, exp, msg) {\n  assert(!dequal(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\n};\n\nnot.type = function (val, exp, msg) {\n  let tmp = typeof val;\n  assert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n};\n\nnot.instance = function (val, exp, msg) {\n  let name = '`' + (exp.name || exp.constructor.name) + '`';\n  assert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\n};\n\nnot.snapshot = function (val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\n};\n\nnot.fixture = function (val, exp, msg) {\n  val = dedent(val);\n  exp = dedent(exp);\n  assert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\n};\n\nnot.match = function (val, exp, msg) {\n  if (typeof exp === 'string') {\n    assert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include \"${exp}\" substring`, msg);\n  } else {\n    assert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\n  }\n};\n\nnot.throws = function (blk, exp, msg) {\n  if (!msg && typeof exp === 'string') {\n    msg = exp;\n    exp = null;\n  }\n\n  try {\n    blk();\n  } catch (err) {\n    if (typeof exp === 'function') {\n      assert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\n    } else if (exp instanceof RegExp) {\n      assert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n    } else if (!exp) {\n      assert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\n    }\n  }\n};","map":{"version":3,"sources":["C:/reactjs/projects/contra/archivo/react-archivo/node_modules/uvu/assert/index.mjs"],"names":["dequal","compare","lines","dedent","str","replace","arr","match","i","min","len","length","Math","RegExp","Assertion","Error","constructor","opts","message","name","code","captureStackTrace","details","generated","operator","expects","actual","assert","bool","detailer","backup","msg","ok","val","is","exp","equal","unreachable","type","tmp","instance","includes","test","String","snapshot","lineNums","x","y","fixture","throws","blk","err","not"],"mappings":"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","sourcesContent":["import { dequalÂ } from 'dequal';\nimport { compare, lines } from 'uvu/diff';\n\nfunction dedent(str) {\n\tstr = str.replace(/\\r?\\n/g, '\\n');\n  let arr = str.match(/^[ \\t]*(?=\\S)/gm);\n  let i = 0, min = 1/0, len = (arr||[]).length;\n  for (; i < len; i++) min = Math.min(min, arr[i].length);\n  return len && min ? str.replace(new RegExp(`^[ \\\\t]{${min}}`, 'gm'), '') : str;\n}\n\nexport class Assertion extends Error {\n\tconstructor(opts={}) {\n\t\tsuper(opts.message);\n\t\tthis.name = 'Assertion';\n\t\tthis.code = 'ERR_ASSERTION';\n\t\tif (Error.captureStackTrace) {\n\t\t\tError.captureStackTrace(this, this.constructor);\n\t\t}\n\t\tthis.details = opts.details || false;\n\t\tthis.generated = !!opts.generated;\n\t\tthis.operator = opts.operator;\n\t\tthis.expects = opts.expects;\n\t\tthis.actual = opts.actual;\n\t}\n}\n\nfunction assert(bool, actual, expects, operator, detailer, backup, msg) {\n\tif (bool) return;\n\tlet message = msg || backup;\n\tif (msg instanceof Error) throw msg;\n\tlet details = detailer && detailer(actual, expects);\n\tthrow new Assertion({ actual, expects, operator, message, details, generated: !msg });\n}\n\nexport function ok(val, msg) {\n\tassert(!!val, false, true, 'ok', false, 'Expected value to be truthy', msg);\n}\n\nexport function is(val, exp, msg) {\n\tassert(val === exp, val, exp, 'is', compare, 'Expected values to be strictly equal:', msg);\n}\n\nexport function equal(val, exp, msg) {\n\tassert(dequal(val, exp), val, exp, 'equal', compare, 'Expected values to be deeply equal:', msg);\n}\n\nexport function unreachable(msg) {\n\tassert(false, true, false, 'unreachable', false, 'Expected not to be reached!', msg);\n}\n\nexport function type(val, exp, msg) {\n\tlet tmp = typeof val;\n\tassert(tmp === exp, tmp, exp, 'type', false, `Expected \"${tmp}\" to be \"${exp}\"`, msg);\n}\n\nexport function instance(val, exp, msg) {\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\n\tassert(val instanceof exp, val, exp, 'instance', false, `Expected value to be an instance of ${name}`, msg);\n}\n\nexport function match(val, exp, msg) {\n\tif (typeof exp === 'string') {\n\t\tassert(val.includes(exp), val, exp, 'match', false, `Expected value to include \"${exp}\" substring`, msg);\n\t} else {\n\t\tassert(exp.test(val), val, exp, 'match', false, `Expected value to match \\`${String(exp)}\\` pattern`, msg);\n\t}\n}\n\nexport function snapshot(val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val === exp, val, exp, 'snapshot', lines, 'Expected value to match snapshot:', msg);\n}\n\nconst lineNums = (x, y) => lines(x, y, 1);\nexport function fixture(val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val === exp, val, exp, 'fixture', lineNums, 'Expected value to match fixture:', msg);\n}\n\nexport function throws(blk, exp, msg) {\n\tif (!msg && typeof exp === 'string') {\n\t\tmsg = exp; exp = null;\n\t}\n\n\ttry {\n\t\tblk();\n\t\tassert(false, false, true, 'throws', false, 'Expected function to throw', msg);\n\t} catch (err) {\n\t\tif (err instanceof Assertion) throw err;\n\n\t\tif (typeof exp === 'function') {\n\t\t\tassert(exp(err), false, true, 'throws', false, 'Expected function to throw matching exception', msg);\n\t\t} else if (exp instanceof RegExp) {\n\t\t\tassert(exp.test(err.message), false, true, 'throws', false, `Expected function to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n\t\t}\n\t}\n}\n\n// ---\n\nexport function not(val, msg) {\n\tassert(!val, true, false, 'not', false, 'Expected value to be falsey', msg);\n}\n\nnot.ok = not;\n\nis.not = function (val, exp, msg) {\n\tassert(val !== exp, val, exp, 'is.not', false, 'Expected values not to be strictly equal', msg);\n}\n\nnot.equal = function (val, exp, msg) {\n\tassert(!dequal(val, exp), val, exp, 'not.equal', false, 'Expected values not to be deeply equal', msg);\n}\n\nnot.type = function (val, exp, msg) {\n\tlet tmp = typeof val;\n\tassert(tmp !== exp, tmp, exp, 'not.type', false, `Expected \"${tmp}\" not to be \"${exp}\"`, msg);\n}\n\nnot.instance = function (val, exp, msg) {\n\tlet name = '`' + (exp.name || exp.constructor.name) + '`';\n\tassert(!(val instanceof exp), val, exp, 'not.instance', false, `Expected value not to be an instance of ${name}`, msg);\n}\n\nnot.snapshot = function (val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val !== exp, val, exp, 'not.snapshot', false, 'Expected value not to match snapshot', msg);\n}\n\nnot.fixture = function (val, exp, msg) {\n\tval=dedent(val); exp=dedent(exp);\n\tassert(val !== exp, val, exp, 'not.fixture', false, 'Expected value not to match fixture', msg);\n}\n\nnot.match = function (val, exp, msg) {\n\tif (typeof exp === 'string') {\n\t\tassert(!val.includes(exp), val, exp, 'not.match', false, `Expected value not to include \"${exp}\" substring`, msg);\n\t} else {\n\t\tassert(!exp.test(val), val, exp, 'not.match', false, `Expected value not to match \\`${String(exp)}\\` pattern`, msg);\n\t}\n}\n\nnot.throws = function (blk, exp, msg) {\n\tif (!msg && typeof exp === 'string') {\n\t\tmsg = exp; exp = null;\n\t}\n\n\ttry {\n\t\tblk();\n\t} catch (err) {\n\t\tif (typeof exp === 'function') {\n\t\t\tassert(!exp(err), true, false, 'not.throws', false, 'Expected function not to throw matching exception', msg);\n\t\t} else if (exp instanceof RegExp) {\n\t\t\tassert(!exp.test(err.message), true, false, 'not.throws', false, `Expected function not to throw exception matching \\`${String(exp)}\\` pattern`, msg);\n\t\t} else if (!exp) {\n\t\t\tassert(false, true, false, 'not.throws', false, 'Expected function not to throw', msg);\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}