{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\nimport { asciiControl, markdownLineEndingOrSpace, markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\n\nexport function factoryDestination(effects, ok, nok, type, literalType, literalMarkerType, rawType, stringType, max) {\n  const limit = max || Number.POSITIVE_INFINITY;\n  let balance = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    if (code === codes.lessThan) {\n      effects.enter(type);\n      effects.enter(literalType);\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      return destinationEnclosedBefore;\n    }\n\n    if (code === codes.eof || code === codes.rightParenthesis || asciiControl(code)) {\n      return nok(code);\n    }\n\n    effects.enter(type);\n    effects.enter(rawType);\n    effects.enter(stringType);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return destinationRaw(code);\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosedBefore(code) {\n    if (code === codes.greaterThan) {\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      effects.exit(literalType);\n      effects.exit(type);\n      return ok;\n    }\n\n    effects.enter(stringType);\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return destinationEnclosed(code);\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosed(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.chunkString);\n      effects.exit(stringType);\n      return destinationEnclosedBefore(code);\n    }\n\n    if (code === codes.eof || code === codes.lessThan || markdownLineEnding(code)) {\n      return nok(code);\n    }\n\n    effects.consume(code);\n    return code === codes.backslash ? destinationEnclosedEscape : destinationEnclosed;\n  }\n  /** @type {State} */\n\n\n  function destinationEnclosedEscape(code) {\n    if (code === codes.lessThan || code === codes.greaterThan || code === codes.backslash) {\n      effects.consume(code);\n      return destinationEnclosed;\n    }\n\n    return destinationEnclosed(code);\n  }\n  /** @type {State} */\n\n\n  function destinationRaw(code) {\n    if (code === codes.leftParenthesis) {\n      if (++balance > limit) return nok(code);\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    if (code === codes.rightParenthesis) {\n      if (!balance--) {\n        effects.exit(types.chunkString);\n        effects.exit(stringType);\n        effects.exit(rawType);\n        effects.exit(type);\n        return ok(code);\n      }\n\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code);\n      effects.exit(types.chunkString);\n      effects.exit(stringType);\n      effects.exit(rawType);\n      effects.exit(type);\n      return ok(code);\n    }\n\n    if (asciiControl(code)) return nok(code);\n    effects.consume(code);\n    return code === codes.backslash ? destinationRawEscape : destinationRaw;\n  }\n  /** @type {State} */\n\n\n  function destinationRawEscape(code) {\n    if (code === codes.leftParenthesis || code === codes.rightParenthesis || code === codes.backslash) {\n      effects.consume(code);\n      return destinationRaw;\n    }\n\n    return destinationRaw(code);\n  }\n}","map":{"version":3,"sources":["C:/reactjs/Udemy/NetCore/react-peliculas/node_modules/micromark-factory-destination/dev/index.js"],"names":["asciiControl","markdownLineEndingOrSpace","markdownLineEnding","codes","constants","types","factoryDestination","effects","ok","nok","type","literalType","literalMarkerType","rawType","stringType","max","limit","Number","POSITIVE_INFINITY","balance","start","code","lessThan","enter","consume","exit","destinationEnclosedBefore","eof","rightParenthesis","chunkString","contentType","contentTypeString","destinationRaw","greaterThan","destinationEnclosed","backslash","destinationEnclosedEscape","leftParenthesis","destinationRawEscape"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Effects} Effects\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {\n  asciiControl,\n  markdownLineEndingOrSpace,\n  markdownLineEnding\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/**\n * @param {Effects} effects\n * @param {State} ok\n * @param {State} nok\n * @param {string} type\n * @param {string} literalType\n * @param {string} literalMarkerType\n * @param {string} rawType\n * @param {string} stringType\n * @param {number} [max=Infinity]\n * @returns {State}\n */\n// eslint-disable-next-line max-params\nexport function factoryDestination(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  const limit = max || Number.POSITIVE_INFINITY\n  let balance = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    if (code === codes.lessThan) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return destinationEnclosedBefore\n    }\n\n    if (\n      code === codes.eof ||\n      code === codes.rightParenthesis ||\n      asciiControl(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return destinationRaw(code)\n  }\n\n  /** @type {State} */\n  function destinationEnclosedBefore(code) {\n    if (code === codes.greaterThan) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return destinationEnclosed(code)\n  }\n\n  /** @type {State} */\n  function destinationEnclosed(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.chunkString)\n      effects.exit(stringType)\n      return destinationEnclosedBefore(code)\n    }\n\n    if (\n      code === codes.eof ||\n      code === codes.lessThan ||\n      markdownLineEnding(code)\n    ) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? destinationEnclosedEscape\n      : destinationEnclosed\n  }\n\n  /** @type {State} */\n  function destinationEnclosedEscape(code) {\n    if (\n      code === codes.lessThan ||\n      code === codes.greaterThan ||\n      code === codes.backslash\n    ) {\n      effects.consume(code)\n      return destinationEnclosed\n    }\n\n    return destinationEnclosed(code)\n  }\n\n  /** @type {State} */\n  function destinationRaw(code) {\n    if (code === codes.leftParenthesis) {\n      if (++balance > limit) return nok(code)\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === codes.rightParenthesis) {\n      if (!balance--) {\n        effects.exit(types.chunkString)\n        effects.exit(stringType)\n        effects.exit(rawType)\n        effects.exit(type)\n        return ok(code)\n      }\n\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code)\n      effects.exit(types.chunkString)\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (asciiControl(code)) return nok(code)\n    effects.consume(code)\n    return code === codes.backslash ? destinationRawEscape : destinationRaw\n  }\n\n  /** @type {State} */\n  function destinationRawEscape(code) {\n    if (\n      code === codes.leftParenthesis ||\n      code === codes.rightParenthesis ||\n      code === codes.backslash\n    ) {\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    return destinationRaw(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}