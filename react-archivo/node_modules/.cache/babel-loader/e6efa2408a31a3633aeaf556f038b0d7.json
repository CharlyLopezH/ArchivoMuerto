{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { push, splice } from 'micromark-util-chunked';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { resolveAll } from 'micromark-util-resolve-all';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n};\n/** @type {Construct} */\n\nconst resourceConstruct = {\n  tokenize: tokenizeResource\n};\n/** @type {Construct} */\n\nconst fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n};\n/** @type {Construct} */\n\nconst collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n};\n/** @type {Resolver} */\n\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  /** @type {Token} */\n\n  let token;\n\n  while (++index < events.length) {\n    token = events[index][1];\n\n    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2);\n      token.type = types.data;\n      index++;\n    }\n  }\n\n  return events;\n}\n/** @type {Resolver} */\n\n\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  /** @type {Token} */\n\n  let token;\n  /** @type {number|undefined} */\n\n  let open;\n  /** @type {number|undefined} */\n\n  let close;\n  /** @type {Event[]} */\n\n  let media; // Find an opening.\n\n  while (index--) {\n    token = events[index][1];\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (token.type === types.link || token.type === types.labelLink && token._inactive) {\n        break;\n      } // Mark other link openings as inactive, as we can’t have links in\n      // links.\n\n\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === 'enter' && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {\n        open = index;\n\n        if (token.type !== types.labelLink) {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index;\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found');\n  assert(close !== undefined, '`close` is supposed to be found');\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  };\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  };\n  media = [['enter', group, context], ['enter', label, context]]; // Opening marker.\n\n  media = push(media, events.slice(open + 1, open + offset + 3)); // Text open.\n\n  media = push(media, [['enter', text, context]]); // Between.\n\n  media = push(media, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + offset + 4, close - 3), context)); // Text close, marker close, label close.\n\n  media = push(media, [['exit', text, context], events[close - 2], events[close - 1], ['exit', label, context]]); // Reference, resource, or so.\n\n  media = push(media, events.slice(close + 1)); // Media close.\n\n  media = push(media, [['exit', group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Token} */\n\n  let labelStart;\n  /** @type {boolean} */\n\n  let defined; // Find an opening.\n\n  while (index--) {\n    if ((self.events[index][1].type === types.labelImage || self.events[index][1].type === types.labelLink) && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`');\n\n    if (!labelStart) {\n      return nok(code);\n    } // It’s a balanced bracket, but contains a link.\n\n\n    if (labelStart._inactive) return balanced(code);\n    defined = self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    })));\n    effects.enter(types.labelEnd);\n    effects.enter(types.labelMarker);\n    effects.consume(code);\n    effects.exit(types.labelMarker);\n    effects.exit(types.labelEnd);\n    return afterLabelEnd;\n  }\n  /** @type {State} */\n\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(resourceConstruct, ok, defined ? ok : balanced)(code);\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(fullReferenceConstruct, ok, defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced)(code);\n    } // Shortcut reference: `[asd]`?\n\n\n    return defined ? ok(code) : balanced(code);\n  }\n  /** @type {State} */\n\n\n  function balanced(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren');\n    effects.enter(types.resource);\n    effects.enter(types.resourceMarker);\n    effects.consume(code);\n    effects.exit(types.resourceMarker);\n    return factoryWhitespace(effects, open);\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === codes.rightParenthesis) {\n      return end(code);\n    }\n\n    return factoryDestination(effects, destinationAfter, nok, types.resourceDestination, types.resourceDestinationLiteral, types.resourceDestinationLiteralMarker, types.resourceDestinationRaw, types.resourceDestinationString, constants.linkResourceDestinationBalanceMax)(code);\n  }\n  /** @type {State} */\n\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end(code);\n  }\n  /** @type {State} */\n\n\n  function between(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, factoryWhitespace(effects, end), nok, types.resourceTitle, types.resourceTitleMarker, types.resourceTitleString)(code);\n    }\n\n    return end(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker);\n      effects.consume(code);\n      effects.exit(types.resourceMarker);\n      effects.exit(types.resource);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    return factoryLabel.call(self, effects, afterLabel, nok, types.reference, types.referenceMarker, types.referenceString)(code);\n  }\n  /** @type {State} */\n\n\n  function afterLabel(code) {\n    return self.parser.defined.includes(normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1))) ? ok(code) : nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket');\n    effects.enter(types.reference);\n    effects.enter(types.referenceMarker);\n    effects.consume(code);\n    effects.exit(types.referenceMarker);\n    return open;\n  }\n  /** @type {State} */\n\n\n  function open(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker);\n      effects.consume(code);\n      effects.exit(types.referenceMarker);\n      effects.exit(types.reference);\n      return ok;\n    }\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["C:/reactjs/projects/contra/archivo/react-archivo/node_modules/micromark-core-commonmark/dev/lib/label-end.js"],"names":["ok","assert","factoryDestination","factoryLabel","factoryTitle","factoryWhitespace","markdownLineEndingOrSpace","push","splice","normalizeIdentifier","resolveAll","codes","constants","types","labelEnd","name","tokenize","tokenizeLabelEnd","resolveTo","resolveToLabelEnd","resolveAllLabelEnd","resourceConstruct","tokenizeResource","fullReferenceConstruct","tokenizeFullReference","collapsedReferenceConstruct","tokenizeCollapsedReference","events","index","token","length","type","labelImage","labelLink","data","context","offset","open","close","media","link","_inactive","_balanced","undefined","group","image","start","Object","assign","end","label","text","labelText","slice","parser","constructs","insideSpan","null","effects","nok","self","labelStart","defined","code","rightSquareBracket","balanced","includes","sliceSerialize","now","enter","labelMarker","consume","exit","afterLabelEnd","leftParenthesis","attempt","leftSquareBracket","resource","resourceMarker","rightParenthesis","destinationAfter","resourceDestination","resourceDestinationLiteral","resourceDestinationLiteralMarker","resourceDestinationRaw","resourceDestinationString","linkResourceDestinationBalanceMax","between","quotationMark","apostrophe","resourceTitle","resourceTitleMarker","resourceTitleString","call","afterLabel","reference","referenceMarker","referenceString"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Event} Event\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Code} Code\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {markdownLineEndingOrSpace} from 'micromark-util-character'\nimport {push, splice} from 'micromark-util-chunked'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {resolveAll} from 'micromark-util-resolve-all'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\n\n/** @type {Construct} */\nconst resourceConstruct = {tokenize: tokenizeResource}\n/** @type {Construct} */\nconst fullReferenceConstruct = {tokenize: tokenizeFullReference}\n/** @type {Construct} */\nconst collapsedReferenceConstruct = {tokenize: tokenizeCollapsedReference}\n\n/** @type {Resolver} */\nfunction resolveAllLabelEnd(events) {\n  let index = -1\n  /** @type {Token} */\n  let token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      token.type === types.labelImage ||\n      token.type === types.labelLink ||\n      token.type === types.labelEnd\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === types.labelImage ? 4 : 2)\n      token.type = types.data\n      index++\n    }\n  }\n\n  return events\n}\n\n/** @type {Resolver} */\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length\n  let offset = 0\n  /** @type {Token} */\n  let token\n  /** @type {number|undefined} */\n  let open\n  /** @type {number|undefined} */\n  let close\n  /** @type {Event[]} */\n  let media\n\n  // Find an opening.\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, we’ve been here before.\n      if (\n        token.type === types.link ||\n        (token.type === types.labelLink && token._inactive)\n      ) {\n        break\n      }\n\n      // Mark other link openings as inactive, as we can’t have links in\n      // links.\n      if (events[index][0] === 'enter' && token.type === types.labelLink) {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === types.labelImage || token.type === types.labelLink) &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== types.labelLink) {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index\n    }\n  }\n\n  assert(open !== undefined, '`open` is supposed to be found')\n  assert(close !== undefined, '`close` is supposed to be found')\n\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n\n  const label = {\n    type: types.label,\n    start: Object.assign({}, events[open][1].start),\n    end: Object.assign({}, events[close][1].end)\n  }\n\n  const text = {\n    type: types.labelText,\n    start: Object.assign({}, events[open + offset + 2][1].end),\n    end: Object.assign({}, events[close - 2][1].start)\n  }\n\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ]\n\n  // Opening marker.\n  media = push(media, events.slice(open + 1, open + offset + 3))\n\n  // Text open.\n  media = push(media, [['enter', text, context]])\n\n  // Between.\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  )\n\n  // Text close, marker close, label close.\n  media = push(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ])\n\n  // Reference, resource, or so.\n  media = push(media, events.slice(close + 1))\n\n  // Media close.\n  media = push(media, [['exit', group, context]])\n\n  splice(events, open, events.length, media)\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Token} */\n  let labelStart\n  /** @type {boolean} */\n  let defined\n\n  // Find an opening.\n  while (index--) {\n    if (\n      (self.events[index][1].type === types.labelImage ||\n        self.events[index][1].type === types.labelLink) &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    if (!labelStart) {\n      return nok(code)\n    }\n\n    // It’s a balanced bracket, but contains a link.\n    if (labelStart._inactive) return balanced(code)\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({start: labelStart.end, end: self.now()})\n      )\n    )\n    effects.enter(types.labelEnd)\n    effects.enter(types.labelMarker)\n    effects.consume(code)\n    effects.exit(types.labelMarker)\n    effects.exit(types.labelEnd)\n    return afterLabelEnd\n  }\n\n  /** @type {State} */\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    }\n\n    // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    }\n\n    // Shortcut reference: `[asd]`?\n    return defined ? ok(code) : balanced(code)\n  }\n\n  /** @type {State} */\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftParenthesis, 'expected left paren')\n    effects.enter(types.resource)\n    effects.enter(types.resourceMarker)\n    effects.consume(code)\n    effects.exit(types.resourceMarker)\n    return factoryWhitespace(effects, open)\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.rightParenthesis) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code)\n  }\n\n  /** @type {State} */\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n\n  /** @type {State} */\n  function between(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code)\n    }\n\n    return end(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker)\n      effects.consume(code)\n      effects.exit(types.resourceMarker)\n      effects.exit(types.resource)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeFullReference(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code)\n  }\n\n  /** @type {State} */\n  function afterLabel(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    )\n      ? ok(code)\n      : nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected left bracket')\n    effects.enter(types.reference)\n    effects.enter(types.referenceMarker)\n    effects.consume(code)\n    effects.exit(types.referenceMarker)\n    return open\n  }\n\n  /** @type {State} */\n  function open(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker)\n      effects.consume(code)\n      effects.exit(types.referenceMarker)\n      effects.exit(types.reference)\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}