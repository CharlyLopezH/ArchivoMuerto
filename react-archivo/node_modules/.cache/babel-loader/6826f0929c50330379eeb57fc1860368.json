{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n/** @type {Construct} */\n\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this;\n  /** @type {string} */\n\n  let identifier;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter(types.definition);\n    return factoryLabel.call(self, effects, labelAfter, nok, types.definitionLabel, types.definitionLabelMarker, types.definitionLabelString)(code);\n  }\n  /** @type {State} */\n\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker);\n      effects.consume(code);\n      effects.exit(types.definitionMarker); // Note: blank lines can’t exist in content.\n\n      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, types.whitespace), factorySpace(effects, after, types.whitespace)), nok, types.definitionDestination, types.definitionDestinationLiteral, types.definitionDestinationLiteralMarker, types.definitionDestinationRaw, types.definitionDestinationString));\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition);\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier);\n      }\n\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);\n  }\n  /** @type {State} */\n\n\n  function before(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, factorySpace(effects, after, types.whitespace), nok, types.definitionTitle, types.definitionTitleMarker, types.definitionTitleString)(code);\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["C:/reactjs/projects/contra/archivo/react-archivo/node_modules/micromark-core-commonmark/dev/lib/definition.js"],"names":["ok","assert","factoryDestination","factoryLabel","factorySpace","factoryTitle","factoryWhitespace","normalizeIdentifier","markdownLineEnding","markdownLineEndingOrSpace","codes","types","definition","name","tokenize","tokenizeDefinition","titleConstruct","tokenizeTitle","partial","effects","nok","self","identifier","start","code","leftSquareBracket","enter","call","labelAfter","definitionLabel","definitionLabelMarker","definitionLabelString","sliceSerialize","events","length","slice","colon","definitionMarker","consume","exit","attempt","after","whitespace","definitionDestination","definitionDestinationLiteral","definitionDestinationLiteralMarker","definitionDestinationRaw","definitionDestinationString","eof","parser","defined","includes","push","before","quotationMark","apostrophe","leftParenthesis","definitionTitle","definitionTitleMarker","definitionTitleString"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factoryDestination} from 'micromark-factory-destination'\nimport {factoryLabel} from 'micromark-factory-label'\nimport {factorySpace} from 'micromark-factory-space'\nimport {factoryTitle} from 'micromark-factory-title'\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const definition = {name: 'definition', tokenize: tokenizeDefinition}\n\n/** @type {Construct} */\nconst titleConstruct = {tokenize: tokenizeTitle, partial: true}\n\n/** @type {Tokenizer} */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this\n  /** @type {string} */\n  let identifier\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter(types.definition)\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      types.definitionLabel,\n      types.definitionLabelMarker,\n      types.definitionLabelString\n    )(code)\n  }\n\n  /** @type {State} */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker)\n      effects.consume(code)\n      effects.exit(types.definitionMarker)\n\n      // Note: blank lines can’t exist in content.\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, types.whitespace),\n            factorySpace(effects, after, types.whitespace)\n          ),\n          nok,\n          types.definitionDestination,\n          types.definitionDestinationLiteral,\n          types.definitionDestinationLiteralMarker,\n          types.definitionDestinationRaw,\n          types.definitionDestinationString\n        )\n      )\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition)\n\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n\n  /** @type {State} */\n  function before(code) {\n    if (\n      code === codes.quotationMark ||\n      code === codes.apostrophe ||\n      code === codes.leftParenthesis\n    ) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, types.whitespace),\n        nok,\n        types.definitionTitle,\n        types.definitionTitleMarker,\n        types.definitionTitleString\n      )(code)\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}